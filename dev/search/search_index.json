{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>Pixi is a package management tool for developers. It allows the developer to install libraries and applications in a reproducible way. Use pixi cross-platform, on Windows, Mac and Linux.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install <code>pixi</code> you can run the following command in your terminal:</p> Linux &amp; macOSWindows <pre><code>curl -fsSL https://pixi.sh/install.sh | bash\n</code></pre> <p>The above invocation will automatically download the latest version of <code>pixi</code>, extract it, and move the <code>pixi</code> binary to <code>~/.pixi/bin</code>. If this directory does not already exist, the script will create it.</p> <p>The script will also update your <code>~/.bash_profile</code> to include <code>~/.pixi/bin</code> in your PATH, allowing you to invoke the <code>pixi</code> command from anywhere.</p> <p><code>PowerShell</code>: <pre><code>iwr -useb https://pixi.sh/install.ps1 | iex\n</code></pre> <code>winget</code>: <pre><code>winget install prefix-dev.pixi\n</code></pre> The above invocation will automatically download the latest version of <code>pixi</code>, extract it, and move the <code>pixi</code> binary to <code>LocalAppData/pixi/bin</code>. If this directory does not already exist, the script will create it.</p> <p>The command will also automatically add <code>LocalAppData/pixi/bin</code> to your path allowing you to invoke <code>pixi</code> from anywhere.</p> <p>Tip</p> <p>You might need to restart your terminal or source your shell for the changes to take effect.</p> <p>You can find more options for the installation script here.</p>"},{"location":"#autocompletion","title":"Autocompletion","text":"<p>To get autocompletion run:</p> Linux &amp; macOSWindows <pre><code># Pick your shell (use `echo $SHELL` to find the shell you are using.):\necho 'eval \"$(pixi completion --shell bash)\"' &gt;&gt; ~/.bashrc\necho 'eval \"$(pixi completion --shell zsh)\"' &gt;&gt; ~/.zshrc\necho 'pixi completion --shell fish | source' &gt;&gt; ~/.config/fish/config.fish\necho 'eval (pixi completion --shell elvish | slurp)' &gt;&gt; ~/.elvish/rc.elv\n</code></pre> <p>PowerShell: <pre><code>Add-Content -Path $PROFILE -Value '(&amp; pixi completion --shell powershell) | Out-String | Invoke-Expression'\n</code></pre></p> <p>Failure because no profile file exists</p> <p>Make sure your profile file exists, otherwise create it with: <pre><code>New-Item -Path $PROFILE -ItemType File -Force\n</code></pre></p> <p>And then restart the shell or source the shell config file.</p>"},{"location":"#alternative-installation-methods","title":"Alternative installation methods","text":"<p>Although we recommend installing pixi through the above method we also provide additional installation methods.</p>"},{"location":"#homebrew","title":"Homebrew","text":"<p>Pixi is available via homebrew. To install pixi via homebrew simply run:</p> <pre><code>brew install pixi\n</code></pre>"},{"location":"#windows-installer","title":"Windows installer","text":"<p>We provide an <code>msi</code> installer on our GitHub releases page. The installer will download pixi and add it to the path.</p>"},{"location":"#install-from-source","title":"Install from source","text":"<p>pixi is 100% written in Rust, and therefore it can be installed, built and tested with cargo. To start using pixi from a source build run:</p> <pre><code>cargo install --locked --git https://github.com/prefix-dev/pixi.git\n</code></pre> <p>or when you want to make changes use:</p> <pre><code>cargo build\ncargo test\n</code></pre> <p>If you have any issues building because of the dependency on <code>rattler</code> checkout its compile steps.</p>"},{"location":"#installer-script-options","title":"Installer script options","text":"Linux &amp; macOSWindows <p>The installation script has several options that can be manipulated through environment variables.</p> Variable Description Default Value <code>VERSION</code> The version of pixi getting installed, can be used to up- or down-grade. <code>latest</code> <code>PIXI_HOME</code> The location of the binary folder. <code>$HOME/.pixi</code> <code>PIXI_ARCH</code> The architecture the pixi version was built for. <code>uname -m</code> <code>PIXI_NO_PATH_UPDATE</code> If set the <code>$PATH</code> will not be updated to add <code>pixi</code> to it. <code>TMP_DIR</code> The temporary directory the script uses to download to and unpack the binary from. <code>/tmp</code> <p>For example, on Apple Silicon, you can force the installation of the x86 version: <pre><code>PIXI_ARCH=x86_64 curl -fsSL https://pixi.sh/install.sh | bash\n</code></pre> Or set the version <pre><code>PIXI_VERSION=v0.18.0 curl -fsSL https://pixi.sh/install.sh | bash\n</code></pre></p> <p>The installation script has several options that can be manipulated through environment variables.</p> Variable Environment variable Description Default Value <code>PixiVersion</code> <code>PIXI_VERSION</code> The version of pixi getting installed, can be used to up- or down-grade. <code>latest</code> <code>PixiHome</code> <code>PIXI_HOME</code> The location of the installation. <code>$Env:USERPROFILE\\.pixi</code> <code>NoPathUpdate</code> If set, the <code>$PATH</code> will not be updated to add <code>pixi</code> to it. <p>For example, set the version using:</p> <pre><code>iwr -useb https://pixi.sh/install.ps1 | iex -Args \"-PixiVersion v0.18.0\"\n</code></pre>"},{"location":"#update","title":"Update","text":"<p>Updating is as simple as installing, rerunning the installation script gets you the latest version.</p> <p><pre><code>pixi self-update\n</code></pre> Or get a specific pixi version using: <pre><code>pixi self-update --version x.y.z\n</code></pre></p> <p>Note</p> <p>If you've used a package manager like <code>brew</code>, <code>mamba</code>, <code>conda</code>, <code>paru</code> etc. to install <code>pixi</code>. It's preferable to use the built-in update mechanism. e.g. <code>brew upgrade pixi</code>.</p>"},{"location":"#uninstall","title":"Uninstall","text":"<p>To uninstall pixi from your system, simply remove the binary.</p> Linux &amp; macOSWindows <pre><code>rm ~/.pixi/bin/pixi\n</code></pre> <pre><code>$PIXI_BIN = \"$Env:LocalAppData\\pixi\\bin\\pixi\"; Remove-Item -Path $PIXI_BIN\n</code></pre> <p>After this command, you can still use the tools you installed with pixi. To remove these as well, just remove the whole <code>~/.pixi</code> directory and remove the directory from your path.</p>"},{"location":"Community/","title":"Community","text":"<p>When you want to show your users and contributors that they can use pixi in your repo, you can use the following badge:</p> <p></p> <pre><code>[![Pixi Badge](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/prefix-dev/pixi/main/assets/badge/v0.json)](https://pixi.sh)\n</code></pre> <p>Customize your badge</p> <p>To further customize the look and feel of your badge, you can add <code>&amp;style=&lt;custom-style&gt;</code> at the end of the URL. See the documentation on shields.io for more info.</p>"},{"location":"Community/#built-using-pixi","title":"Built using Pixi","text":"<ul> <li>Deltares:<ul> <li>Ribasim: Water resources model</li> <li>Ribasim-NL: Ribasim water resources modeling in the Netherlands</li> <li>iMOD Python: Make massive MODFLOW models</li> <li>iMOD Coupler: Application for coupling hydrological kernels</li> <li>iMOD Documentation: Documentation of the iMOD suite.</li> <li>Xugrid:  Xarray and unstructured grids</li> <li>Numba celltree: Celltree data structure for searching for points, lines, boxes, and cells (convex polygons) in a two dimensional unstructured mesh.</li> <li>QGIS-Tim: QGIS plugin and utilities for TimML multi-layer analytic element model</li> <li>Pandamesh: From geodataframe to mesh</li> <li>Wflow: Hydrological modeling framework</li> <li>HydroMT: Automated and reproducible model building and analysis</li> <li>HydroMT SFINCS: SFINCS plugin for HydroMT</li> <li>PyFlwDir: Fast methods to work with hydro- and topography data in pure Python.</li> </ul> </li> <li>USGS:<ul> <li>MODFLOW 6: USGS modular hydrological model</li> </ul> </li> </ul> <ul> <li>jiaxiyang/cpp_project_guideline: Guide the way beginners make their c++ projects.</li> <li>karelze/tclf: A python library for trade classification\u26a1</li> <li>quantco/polarify: Simplifying conditional Polars Expressions with Python \ud83d\udc0d \ud83d\udc3b\u200d\u2744\ufe0f</li> <li>quantco/slim-trees: Pickle your ML models more efficiently for deployment \ud83d\ude80</li> <li>hex-inc/vegafusion: Serverside scaling of Vega and Altair visualizations in Rust, Python, WASM, and Java</li> <li>pablovela5620/arxiv-researcher: Summarize PDF's and Arixv papers with Langchain and Nougat \ud83e\udd89</li> <li>HaoZeke/xtsci-dist: Incremental <code>scipy</code> port using <code>xtensor</code></li> <li>LFortran: A modern cross-platform Fortran compiler</li> <li>Rerun: Rerun is an SDK for building time aware visualizations of multimodal data.</li> <li>conda-auth: a conda plugin providing more secure authentication support to conda.</li> <li>py-rattler: Build your own conda environment manager using the python wrapper of our Rattler backend.</li> </ul>"},{"location":"FAQ/","title":"Frequently asked questions","text":""},{"location":"FAQ/#what-is-the-difference-with-conda-mamba-poetry-pip","title":"What is the difference with <code>conda</code>, <code>mamba</code>, <code>poetry</code>, <code>pip</code>","text":"Tool Installs python Builds packages Runs predefined tasks Has lock files builtin Fast Use without python Conda \u2705 \u274c \u274c \u274c \u274c \u274c Mamba \u2705 \u274c \u274c \u274c \u2705 \u2705 Pip \u274c \u2705 \u274c \u274c \u274c \u274c Pixi \u2705 \ud83d\udea7 \u2705 \u2705 \u2705 \u2705 Poetry \u274c \u2705 \u274c \u2705 \u274c \u274c"},{"location":"FAQ/#why-the-name-pixi","title":"Why the name <code>pixi</code>","text":"<p>Starting with the name <code>prefix</code> we iterated until we had a name that was easy to pronounce, spell and remember. There also wasn't a cli tool yet using that name. Unlike <code>px</code>, <code>pex</code>, <code>pax</code>, etc. We think it sparks curiosity and fun, if you don't agree, I'm sorry, but you can always alias it to whatever you like.</p> Linux &amp; macOSWindows <pre><code>alias not_pixi=\"pixi\"\n</code></pre> <p>PowerShell: <pre><code>New-Alias -Name not_pixi -Value pixi\n</code></pre></p>"},{"location":"FAQ/#where-is-pixi-build","title":"Where is <code>pixi build</code>","text":"<p>TL;DR: It's coming we promise!</p> <p><code>pixi build</code> is going to be the subcommand that can generate a conda package out of a pixi project. This requires a solid build tool which we're creating with <code>rattler-build</code> which will be used as a library in pixi.</p>"},{"location":"basic_usage/","title":"Basic usage","text":"<p>Ensure you've got <code>pixi</code> set up. If running <code>pixi</code> doesn't show the help, see the getting started if it doesn't.</p> <pre><code>pixi\n</code></pre> <p>Initialize a new project and navigate to the project directory.</p> <pre><code>pixi init pixi-hello-world\ncd pixi-hello-world\n</code></pre> <p>Add the dependencies you would like to use.</p> <pre><code>pixi add python\n</code></pre> <p>Create a file named <code>hello_world.py</code> in the directory and paste the following code into the file.</p> hello_world.py<pre><code>def hello():\n    print(\"Hello World, to the new revolution in package management.\")\n\nif __name__ == \"__main__\":\n    hello()\n</code></pre> <p>Run the code inside the environment.</p> <pre><code>pixi run python hello_world.py\n</code></pre> <p>You can also put this run command in a task.</p> <pre><code>pixi task add hello python hello_world.py\n</code></pre> <p>After adding the task, you can run the task using its name.</p> <pre><code>pixi run hello\n</code></pre> <p>Use the <code>shell</code> command to activate the environment and start a new shell in there.</p> <pre><code>pixi shell\npython\nexit\n</code></pre> <p>You've just learned the basic features of pixi:</p> <ol> <li>initializing a project</li> <li>adding a dependency.</li> <li>adding a task, and executing it.</li> <li>running a program.</li> </ol> <p>Feel free to play around with what you just learned like adding more tasks, dependencies or code.</p> <p>Happy coding!</p>"},{"location":"basic_usage/#use-pixi-as-a-global-installation-tool","title":"Use pixi as a global installation tool","text":"<p>Use pixi to install tools on your machine.</p> <p>Some notable examples:</p> <pre><code># Awesome cross shell prompt, huge tip when using pixi!\npixi global install starship\n\n# Want to try a different shell?\npixi global install fish\n\n# Install other prefix.dev tools\npixi global install rattler-build\n\n# Install a linter you want to use in multiple projects.\npixi global install ruff\n</code></pre>"},{"location":"basic_usage/#use-pixi-in-github-actions","title":"Use pixi in GitHub Actions","text":"<p>You can use pixi in GitHub Actions to install dependencies and run commands. It supports automatic caching of your environments.</p> <pre><code>- uses: prefix-dev/setup-pixi@v0.5.1\n- run: pixi run cowpy \"Thanks for using pixi\"\n</code></pre> <p>See the GitHub Actions for more details.</p>"},{"location":"vision/","title":"Vision","text":"<p>We created <code>pixi</code> because we want to have a cargo/npm/yarn like package management experience for conda. We really love what the conda packaging ecosystem achieves, but we think that the user experience can be improved a lot. Modern package managers like <code>cargo</code> have shown us, how great a package manager can be. We want to bring that experience to the conda ecosystem.</p>"},{"location":"vision/#pixi-values","title":"Pixi values","text":"<p>We want to make pixi a great experience for everyone, so we have a few values that we want to uphold:</p> <ol> <li>Fast. We want to have a fast package manager, that is able to solve the environment in a few seconds.</li> <li>User Friendly. We want to have a package manager that puts user friendliness on the front-line. Providing easy, accessible and intuitive commands. That have the element of least surprise.</li> <li>Isolated Environment. We want to have isolated environments, that are reproducible and easy to share. Ideally, it should run on all common platforms. The Conda packaging system provides an excellent base for this.</li> <li>Single Tool. We want to integrate most common uses when working on a development project with Pixi, so it should support at least dependency management, command management, building and uploading packages. You should not need to reach to another external tool for this.</li> <li>Fun. It should be fun to use pixi and not cause frustrations, you should not need to think about it a lot and it should generally just get out of your way.</li> </ol>"},{"location":"vision/#conda","title":"Conda","text":"<p>We are building on top of the conda packaging ecosystem, this means that we have a huge number of packages available for different platforms on conda-forge. We believe the conda packaging ecosystem provides a solid base to manage your dependencies. Conda-forge is community maintained and very open to contributions. It is widely used in data science and scientific computing, robotics and other fields. And has a proven track record.</p>"},{"location":"vision/#target-languages","title":"Target languages","text":"<p>Essentially, we are language agnostics, we are targeting any language that can be installed with conda. Including: C++, Python, Rust, Zig etc. But we do believe the python ecosystem can benefit from a good package manager that is based on conda. So we are trying to provide an alternative to existing solutions there. We also think we can provide a good solution for C++ projects, as there are a lot of libraries available on conda-forge today. Pixi also truly shines when using it for multi-language projects e.g. a mix of C++ and Python, because we provide a nice way to build everything up to and including system level packages.</p>"},{"location":"advanced/authentication/","title":"Authenticate pixi with a server","text":"<p>You can authenticate pixi with a server like prefix.dev, a private quetz instance or anaconda.org. Different servers use different authentication methods. In this documentation page, we detail how you can authenticate against the different servers and where the authentication information is stored.</p> <pre><code>Usage: pixi auth login [OPTIONS] &lt;HOST&gt;\n\nArguments:\n  &lt;HOST&gt;  The host to authenticate with (e.g. repo.prefix.dev)\n\nOptions:\n      --token &lt;TOKEN&gt;              The token to use (for authentication with prefix.dev)\n      --username &lt;USERNAME&gt;        The username to use (for basic HTTP authentication)\n      --password &lt;PASSWORD&gt;        The password to use (for basic HTTP authentication)\n      --conda-token &lt;CONDA_TOKEN&gt;  The token to use on anaconda.org / quetz authentication\n  -v, --verbose...                 More output per occurrence\n  -q, --quiet...                   Less output per occurrence\n  -h, --help                       Print help\n</code></pre> <p>The different options are \"token\", \"conda-token\" and \"username + password\".</p> <p>The token variant implements a standard \"Bearer Token\" authentication as is used on the prefix.dev platform. A Bearer Token is sent with every request as an additional header of the form <code>Authentication: Bearer &lt;TOKEN&gt;</code>.</p> <p>The conda-token option is used on anaconda.org and can be used with a quetz server. With this option, the token is sent as part of the URL following this scheme: <code>conda.anaconda.org/t/&lt;TOKEN&gt;/conda-forge/linux-64/...</code>.</p> <p>The last option, username &amp; password, are used for \"Basic HTTP Authentication\". This is the equivalent of adding <code>http://user:password@myserver.com/...</code>. This authentication method can be configured quite easily with a reverse NGinx or Apache server and is thus commonly used in self-hosted systems.</p>"},{"location":"advanced/authentication/#examples","title":"Examples","text":"<p>Login to prefix.dev:</p> <pre><code>pixi auth login prefix.dev --token pfx_jj8WDzvnuTEHGdAhwRZMC1Ag8gSto8\n</code></pre> <p>Login to anaconda.org:</p> <pre><code>pixi auth login anaconda.org --conda-token xy-72b914cc-c105-4ec7-a969-ab21d23480ed\n</code></pre> <p>Login to a basic HTTP secured server:</p> <pre><code>pixi auth login myserver.com --username user --password password\n</code></pre>"},{"location":"advanced/authentication/#where-does-pixi-store-the-authentication-information","title":"Where does pixi store the authentication information?","text":"<p>The storage location for the authentication information is system-dependent. By default, pixi tries to use the keychain to store this sensitive information securely on your machine.</p> <p>On Windows, the credentials are stored in the \"credentials manager\". Searching for <code>rattler</code> (the underlying library pixi uses) you should find any credentials stored by pixi (or other rattler-based programs).</p> <p>On macOS, the passwords are stored in the keychain. To access the password, you can use the <code>Keychain Access</code> program that comes pre-installed on macOS. Searching for <code>rattler</code> (the underlying library pixi uses) you should find any credentials stored by pixi (or other rattler-based programs).</p> <p>On Linux, one can use <code>GNOME Keyring</code> (or just Keyring) to access credentials that are securely stored by <code>libsecret</code>. Searching for <code>rattler</code> should list all the credentials stored by pixi and other rattler-based programs.</p>"},{"location":"advanced/authentication/#fallback-storage","title":"Fallback storage","text":"<p>If you run on a server with none of the aforementioned keychains available, then pixi falls back to store the credentials in an insecure JSON file. This JSON file is located at <code>~/.rattler/credentials.json</code> and contains the credentials.</p>"},{"location":"advanced/authentication/#override-the-authentication-storage","title":"Override the authentication storage","text":"<p>You can use the <code>RATTLER_AUTH_FILE</code> environment variable to override the default location of the credentials file. When this environment variable is set, it provides the only source of authentication data that is used by pixi.</p> <p>E.g.</p> <pre><code>export RATTLER_AUTH_FILE=$HOME/credentials.json\n# You can also specify the file in the command line\npixi global install --auth-file $HOME/credentials.json ...\n</code></pre> <p>The JSON should follow the following format:</p> <pre><code>{\n    \"*.prefix.dev\": {\n        \"BearerToken\": \"your_token\"\n    },\n    \"otherhost.com\": {\n        \"BasicHttp\": {\n            \"username\": \"your_username\",\n            \"password\": \"your_password\"\n        }\n    },\n    \"conda.anaconda.org\": {\n        \"CondaToken\": \"your_token\"\n    }\n}\n</code></pre> <p>Note: if you use a wildcard in the host, any subdomain will match (e.g. <code>*.prefix.dev</code> also matches <code>repo.prefix.dev</code>).</p> <p>Lastly you can set the authentication override file in the global configuration file.</p>"},{"location":"advanced/authentication/#pypi-authentication","title":"PyPI authentication","text":"<p>Currently, we support the following methods for authenticating against PyPI:</p> <ol> <li>keyring authentication.</li> <li><code>.netrc</code> file authentication.</li> </ol> <p>We want to add more methods in the future, so if you have a specific method you would like to see, please let us know.</p>"},{"location":"advanced/authentication/#keyring-authentication","title":"Keyring authentication","text":"<p>Currently, pixi supports the uv method of authentication through the python keyring library. To enable this use the CLI flag <code>--pypi-keyring-provider</code> which can either be set to <code>subprocess</code> (activated) or <code>disabled</code>.</p> <pre><code># From an existing pixi project\npixi install --pypi-keyring-provider subprocess\n</code></pre> <p>This option can also be set in the global configuration file under pypi-config.</p>"},{"location":"advanced/authentication/#installing-keyring","title":"Installing keyring","text":"<p>To install keyring you can use pixi global install:</p> <p>Either use:</p> <pre><code>pixi global install keyring\n</code></pre> GCP and other backends <p>The downside of this method is currently, because you cannot inject into a pixi global environment just yet, that installing different keyring backends is not possible. This allows only the default keyring backend to be used. Give the issue a \ud83d\udc4d up if you would like to see inject as a feature.</p> <p>Or alternatively, you can install keyring using pipx:</p> <pre><code># Install pipx if you haven't already\npixi global install pipx\npipx install keyring\n\n# For Google Artifact Registry, also install and initialize its keyring backend.\n# Inject this into the pipx environment\npipx inject keyring keyrings.google-artifactregistry-auth --index-url https://pypi.org/simple\ngcloud auth login\n</code></pre>"},{"location":"advanced/authentication/#using-keyring-with-basic-auth","title":"Using keyring with Basic Auth","text":"<p>Use keyring to store your credentials e.g:</p> <pre><code>keyring set https://my-index/simple your_username\n# prompt will appear for your password\n</code></pre>"},{"location":"advanced/authentication/#configuration","title":"Configuration","text":"<p>Make sure to include <code>username@</code> in the URL of the registry. An example of this would be:</p> <pre><code>[pypi-options]\nindex-url = \"https://username@custom-registry.com/simple\"\n</code></pre>"},{"location":"advanced/authentication/#gcp","title":"GCP","text":"<p>For Google Artifact Registry, you can use the Google Cloud SDK to authenticate. Make sure to have run <code>gcloud auth login</code> before using pixi. Another thing to note is that you need to add <code>oauth2accesstoken</code> to the URL of the registry. An example of this would be:</p>"},{"location":"advanced/authentication/#configuration_1","title":"Configuration","text":"<pre><code># rest of the pixi.toml\n#\n# Add's the following options to the default feature\n[pypi-options]\nextra-index-urls = [\"https://oauth2accesstoken@&lt;location&gt;-python.pkg.dev/&lt;project&gt;/&lt;repository&gt;/simple\"]\n</code></pre> <p>Note</p> <p>Include the <code>/simple</code> at the end, replace the <code>&lt;location&gt;</code> etc. with your project and repository and location.</p> <p>To find this URL more easily, you can use the <code>gcloud</code> command:</p> <pre><code>gcloud artifacts print-settings python --project=&lt;project&gt; --repository=&lt;repository&gt; --location=&lt;location&gt;\n</code></pre>"},{"location":"advanced/authentication/#installing-your-environment","title":"Installing your environment","text":"<p>To actually install either configure your Global Config, or use the flag: <pre><code>pixi install --pypi-keyring-provider subprocess\n</code></pre></p>"},{"location":"advanced/authentication/#netrc-file","title":"<code>.netrc</code> file","text":"<p><code>pixi</code> allows you to access private registries securely by authenticating with credentials stored in a <code>.netrc</code> file.</p> <ul> <li>The <code>.netrc</code> file can be stored in your home directory (<code>$HOME/.netrc</code> for Unix-like systems)</li> <li>or in the user profile directory on Windows (<code>%HOME%\\_netrc</code>).</li> <li>You can also set up a different location for it using the <code>NETRC</code> variable (<code>export NETRC=/my/custom/location/.netrc</code>).   e.g <code>export NETRC=/my/custom/location/.netrc pixi install</code></li> </ul> <p>In the <code>.netrc</code> file, you store authentication details like this:</p> <p><pre><code>machine registry-name\nlogin admin\npassword admin\n</code></pre> For more details, you can access the .netrc docs.</p>"},{"location":"advanced/channel_priority/","title":"Channel Logic","text":"<p>All logic regarding the decision which dependencies can be installed from which channel is done by the instruction we give the solver.</p> <p>The actual code regarding this is in the <code>rattler_solve</code> crate. This might however be hard to read. Therefore, this document will continue with simplified flow charts.</p>"},{"location":"advanced/channel_priority/#channel-specific-dependencies","title":"Channel specific dependencies","text":"<p>When a user defines a channel per dependency, the solver needs to know the other channels are unusable for this dependency. <pre><code>[project]\nchannels = [\"conda-forge\", \"my-channel\"]\n\n[dependencies]\npackgex = { version = \"*\", channel = \"my-channel\" }\n</code></pre> In the <code>packagex</code> example, the solver will understand that the package is only available in <code>my-channel</code> and will not look for it in <code>conda-forge</code>.</p> <p>The flowchart of the logic that excludes all other channels:</p> <pre><code>flowchart TD\n    A[Start] --&gt; B[Given a Dependency]\n    B --&gt; C{Channel Specific Dependency?}\n    C --&gt;|Yes| D[Exclude All Other Channels for This Package]\n    C --&gt;|No| E{Any Other Dependencies?}\n    E --&gt;|Yes| B\n    E --&gt;|No| F[End]\n    D --&gt; E</code></pre>"},{"location":"advanced/channel_priority/#channel-priority","title":"Channel priority","text":"<p>Channel priority is dictated by the order in the <code>project.channels</code> array, where the first channel is the highest priority. For instance: <pre><code>[project]\nchannels = [\"conda-forge\", \"my-channel\", \"your-channel\"]\n</code></pre> If the package is found in <code>conda-forge</code> the solver will not look for it in <code>my-channel</code> and <code>your-channel</code>, because it tells the solver they are excluded. If the package is not found in <code>conda-forge</code> the solver will look for it in <code>my-channel</code> and if it is found there it will tell the solver to exclude <code>your-channel</code> for this package. This diagram explains the logic: <pre><code>flowchart TD\n    A[Start] --&gt; B[Given a Dependency]\n    B --&gt; C{Loop Over Channels}\n    C --&gt; D{Package in This Channel?}\n    D --&gt;|No| C\n    D --&gt;|Yes| E{\"This the first channel\n     for this package?\"}\n    E --&gt;|Yes| F[Include Package in Candidates]\n    E --&gt;|No| G[Exclude Package from Candidates]\n    F --&gt; H{Any Other Channels?}\n    G --&gt; H\n    H --&gt;|Yes| C\n    H --&gt;|No| I{Any Other Dependencies?}\n    I --&gt;|No| J[End]\n    I --&gt;|Yes| B</code></pre></p> <p>This method ensures the solver only adds a package to the candidates if it's found in the highest priority channel available. If you have 10 channels and the package is found in the 5th channel it will exclude the next 5 channels from the candidates if they also contain the package.</p>"},{"location":"advanced/channel_priority/#use-case-pytorch-and-nvidia-with-conda-forge","title":"Use case: pytorch and nvidia with conda-forge","text":"<p>A common use case is to use <code>pytorch</code> with <code>nvidia</code> drivers, while also needing the <code>conda-forge</code> channel for the main dependencies. <pre><code>[project]\nchannels = [\"nvidia/label/cuda-11.8.0\", \"nvidia\", \"conda-forge\", \"pytorch\"]\nplatforms = [\"linux-64\"]\n\n[dependencies]\ncuda = {version = \"*\", channel=\"nvidia/label/cuda-11.8.0\"}\npytorch = {version = \"2.0.1.*\", channel=\"pytorch\"}\ntorchvision = {version = \"0.15.2.*\", channel=\"pytorch\"}\npytorch-cuda = {version = \"11.8.*\", channel=\"pytorch\"}\npython = \"3.10.*\"\n</code></pre> What this will do is get as much as possible from the <code>nvidia/label/cuda-11.8.0</code> channel, which is actually only the <code>cuda</code> package.</p> <p>Then it will get all packages from the <code>nvidia</code> channel, which is a little more and some packages overlap the <code>nvidia</code> and <code>conda-forge</code> channel. Like the <code>cuda-cudart</code> package, which will now only be retrieved from the <code>nvidia</code> channel because of the priority logic.</p> <p>Then it will get the packages from the <code>conda-forge</code> channel, which is the main channel for the dependencies.</p> <p>But the user only wants the pytorch packages from the <code>pytorch</code> channel, which is why <code>pytorch</code> is added last and the dependencies are added as channel specific dependencies.</p> <p>We don't define the <code>pytorch</code> channel before <code>conda-forge</code> because we want to get as much as possible from the <code>conda-forge</code> as the pytorch channel is not always shipping the best versions of all packages.</p> <p>For example, it also ships the <code>ffmpeg</code> package, but only an old version which doesn't work with the newer pytorch versions. Thus breaking the installation if we would skip the <code>conda-forge</code> channel for <code>ffmpeg</code> with the priority logic.</p>"},{"location":"advanced/channel_priority/#force-a-specific-channel-priority","title":"Force a specific channel priority","text":"<p>If you want to force a specific priority for a channel, you can use the <code>priority</code> (int) key in the channel definition. The higher the number, the higher the priority. Non specified priorities are set to 0 but the index in the array still counts as a priority, where the first in the list has the highest priority.</p> <p>This priority definition is mostly important for multiple environments with different channel priorities, as by default feature channels are prepended to the project channels.</p> <p><pre><code>[project]\nname = \"test_channel_priority\"\nplatforms = [\"linux-64\", \"osx-64\", \"win-64\", \"osx-arm64\"]\nchannels = [\"conda-forge\"]\n\n[feature.a]\nchannels = [\"nvidia\"]\n\n[feature.b]\nchannels = [ \"pytorch\", {channel = \"nvidia\", priority = 1}]\n\n[feature.c]\nchannels = [ \"pytorch\", {channel = \"nvidia\", priority = -1}]\n\n[environments]\na = [\"a\"]\nb = [\"b\"]\nc = [\"c\"]\n</code></pre> This example creates 4 environments, <code>a</code>, <code>b</code>, <code>c</code>, and the default environment. Which will have the following channel order:</p> Environment Resulting Channels order default <code>conda-forge</code> a <code>nvidia</code>, <code>conda-forge</code> b <code>nvidia</code>, <code>pytorch</code>, <code>conda-forge</code> c <code>pytorch</code>, <code>conda-forge</code>, <code>nvidia</code> Check priority result with <code>pixi info</code> <p>Using <code>pixi info</code> you can check the priority of the channels in the environment. <pre><code>pixi info\nEnvironments\n------------\n       Environment: default\n          Features: default\n          Channels: conda-forge\nDependency count: 0\nTarget platforms: linux-64\n\n       Environment: a\n          Features: a, default\n          Channels: nvidia, conda-forge\nDependency count: 0\nTarget platforms: linux-64\n\n       Environment: b\n          Features: b, default\n          Channels: nvidia, pytorch, conda-forge\nDependency count: 0\nTarget platforms: linux-64\n\n       Environment: c\n          Features: c, default\n          Channels: pytorch, conda-forge, nvidia\nDependency count: 0\nTarget platforms: linux-64\n</code></pre></p>"},{"location":"advanced/explain_info_command/","title":"Info command","text":"<p><code>pixi info</code> prints out useful information to debug a situation or to get an overview of your machine/project. This information can also be retrieved in <code>json</code> format using the <code>--json</code> flag, which can be useful for programmatically reading it.</p> Running pixi info in the pixi repo<pre><code>\u279c pixi info\n      Pixi version: 0.13.0\n          Platform: linux-64\n  Virtual packages: __unix=0=0\n                  : __linux=6.5.12=0\n                  : __glibc=2.36=0\n                  : __cuda=12.3=0\n                  : __archspec=1=x86_64\n         Cache dir: /home/user/.cache/rattler/cache\n      Auth storage: /home/user/.rattler/credentials.json\n\nProject\n------------\n           Version: 0.13.0\n     Manifest file: /home/user/development/pixi/pixi.toml\n      Last updated: 25-01-2024 10:29:08\n\nEnvironments\n------------\ndefault\n          Features: default\n          Channels: conda-forge\n  Dependency count: 10\n      Dependencies: pre-commit, rust, openssl, pkg-config, git, mkdocs, mkdocs-material, pillow, cairosvg, compilers\n  Target platforms: linux-64, osx-arm64, win-64, osx-64\n             Tasks: docs, test-all, test, build, lint, install, build-docs\n</code></pre>"},{"location":"advanced/explain_info_command/#global-info","title":"Global info","text":"<p>The first part of the info output is information that is always available and tells you what pixi can read on your machine.</p>"},{"location":"advanced/explain_info_command/#platform","title":"Platform","text":"<p>This defines the platform you're currently on according to pixi. If this is incorrect, please file an issue on the pixi repo.</p>"},{"location":"advanced/explain_info_command/#virtual-packages","title":"Virtual packages","text":"<p>The virtual packages that pixi can find on your machine.</p> <p>In the Conda ecosystem, you can depend on virtual packages. These packages aren't real dependencies that are going to be installed, but rather are being used in the solve step to find if a package can be installed on the machine. A simple example: When a package depends on Cuda drivers being present on the host machine it can do that by depending on the <code>__cuda</code> virtual package. In that case, if pixi cannot find the <code>__cuda</code> virtual package on your machine the installation will fail.</p>"},{"location":"advanced/explain_info_command/#cache-dir","title":"Cache dir","text":"<p>Pixi caches all previously downloaded packages in a cache folder. This cache folder is shared between all pixi projects and globally installed tools. Normally the locations would be:</p> <ol> <li>XDG compliant cache folder when it's available (<code>$XDG_CACHE_HOME/pixi</code>    or <code>$HOME/.cache/pixi</code>)</li> <li>Platform-specific default cache folder:<ul> <li>Linux: <code>$XDG_CACHE_HOME/rattler</code> or <code>$HOME</code>/.cache/rattler</li> <li>macOS: <code>$HOME</code>/Library/Caches/rattler</li> <li>Windows: <code>%APPDATA%\\rattler</code></li> </ul> </li> </ol> <p>When your system is filling up you can easily remove this folder. It will re-download everything it needs the next time you install a project.</p>"},{"location":"advanced/explain_info_command/#auth-storage","title":"Auth storage","text":"<p>Check the authentication documentation</p>"},{"location":"advanced/explain_info_command/#cache-size","title":"Cache size","text":"<p>[requires <code>--extended</code>]</p> <p>The size of the previously mentioned \"Cache dir\" in Mebibytes.</p>"},{"location":"advanced/explain_info_command/#project-info","title":"Project info","text":"<p>Everything below <code>Project</code> is info about the project you're currently in. This info is only available if your path has a manifest file.</p>"},{"location":"advanced/explain_info_command/#manifest-file","title":"Manifest file","text":"<p>The path to the manifest file that describes the project.</p>"},{"location":"advanced/explain_info_command/#last-updated","title":"Last updated","text":"<p>The last time the lock file was updated, either manually or by pixi itself.</p>"},{"location":"advanced/explain_info_command/#environment-info","title":"Environment info","text":"<p>The environment info defined per environment. If you don't have any environments defined, this will only show the <code>default</code> environment.</p>"},{"location":"advanced/explain_info_command/#features","title":"Features","text":"<p>This lists which features are enabled in the environment. For the default this is only <code>default</code></p>"},{"location":"advanced/explain_info_command/#channels","title":"Channels","text":"<p>The list of channels used in this environment.</p>"},{"location":"advanced/explain_info_command/#dependency-count","title":"Dependency count","text":"<p>The amount of dependencies defined that are defined for this environment (not the amount of installed dependencies).</p>"},{"location":"advanced/explain_info_command/#dependencies","title":"Dependencies","text":"<p>The list of dependencies defined for this environment.</p>"},{"location":"advanced/explain_info_command/#target-platforms","title":"Target platforms","text":"<p>The platforms the project has defined.</p>"},{"location":"advanced/github_actions/","title":"GitHub Action","text":"<p>We created prefix-dev/setup-pixi to facilitate using pixi in CI.</p>"},{"location":"advanced/github_actions/#usage","title":"Usage","text":"<pre><code>- uses: prefix-dev/setup-pixi@v0.7.0\n  with:\n    pixi-version: v0.22.0\n    cache: true\n    auth-host: prefix.dev\n    auth-token: ${{ secrets.PREFIX_DEV_TOKEN }}\n- run: pixi run test\n</code></pre> <p>Pin your action versions</p> <p>Since pixi is not yet stable, the API of this action may change between minor versions. Please pin the versions of this action to a specific version (i.e., <code>prefix-dev/setup-pixi@v0.7.0</code>) to avoid breaking changes. You can automatically update the version of this action by using Dependabot.</p> <p>Put the following in your <code>.github/dependabot.yml</code> file to enable Dependabot for your GitHub Actions:</p> .github/dependabot.yml<pre><code>version: 2\nupdates:\n  - package-ecosystem: github-actions\n    directory: /\n    schedule:\n      interval: monthly # (1)!\n    groups:\n      dependencies:\n        patterns:\n          - \"*\"\n</code></pre> <ol> <li>or <code>daily</code>, <code>weekly</code></li> </ol>"},{"location":"advanced/github_actions/#features","title":"Features","text":"<p>To see all available input arguments, see the <code>action.yml</code> file in <code>setup-pixi</code>. The most important features are described below.</p>"},{"location":"advanced/github_actions/#caching","title":"Caching","text":"<p>The action supports caching of the pixi environment. By default, caching is enabled if a <code>pixi.lock</code> file is present. It will then use the <code>pixi.lock</code> file to generate a hash of the environment and cache it. If the cache is hit, the action will skip the installation and use the cached environment. You can specify the behavior by setting the <code>cache</code> input argument.</p> <p>Customize your cache key</p> <p>If you need to customize your cache-key, you can use the <code>cache-key</code> input argument. This will be the prefix of the cache key. The full cache key will be <code>&lt;cache-key&gt;&lt;conda-arch&gt;-&lt;hash&gt;</code>.</p> <p>Only save caches on <code>main</code></p> <p>In order to not exceed the 10 GB cache size limit as fast, you might want to restrict when the cache is saved. This can be done by setting the <code>cache-write</code> argument.</p> <pre><code>- uses: prefix-dev/setup-pixi@v0.5.1\n  with:\n    cache: true\n    cache-write: ${{ github.event_name == 'push' &amp;&amp; github.ref_name == 'main' }}\n</code></pre>"},{"location":"advanced/github_actions/#multiple-environments","title":"Multiple environments","text":"<p>With pixi, you can create multiple environments for different requirements. You can also specify which environment(s) you want to install by setting the <code>environments</code> input argument. This will install all environments that are specified and cache them.</p> <pre><code>[project]\nname = \"my-package\"\nchannels = [\"conda-forge\"]\nplatforms = [\"linux-64\"]\n\n[dependencies]\npython = \"&gt;=3.11\"\npip = \"*\"\npolars = \"&gt;=0.14.24,&lt;0.21\"\n\n[feature.py311.dependencies]\npython = \"3.11.*\"\n[feature.py312.dependencies]\npython = \"3.12.*\"\n\n[environments]\npy311 = [\"py311\"]\npy312 = [\"py312\"]\n</code></pre>"},{"location":"advanced/github_actions/#multiple-environments-using-a-matrix","title":"Multiple environments using a matrix","text":"<p>The following example will install the <code>py311</code> and <code>py312</code> environments in different jobs.</p> <pre><code>test:\n  runs-on: ubuntu-latest\n  strategy:\n    matrix:\n      environment: [py311, py312]\n  steps:\n  - uses: actions/checkout@v4\n  - uses: prefix-dev/setup-pixi@v0.7.0\n    with:\n      environments: ${{ matrix.environment }}\n</code></pre>"},{"location":"advanced/github_actions/#install-multiple-environments-in-one-job","title":"Install multiple environments in one job","text":"<p>The following example will install both the <code>py311</code> and the <code>py312</code> environment on the runner.</p> <pre><code>- uses: prefix-dev/setup-pixi@v0.7.0\n  with:\n    environments: &gt;- # (1)!\n      py311\n      py312\n- run: |\n  pixi run -e py311 test\n  pixi run -e py312 test\n</code></pre> <ol> <li> <p>separated by spaces, equivalent to</p> <pre><code>environments: py311 py312\n</code></pre> </li> </ol> <p>Caching behavior if you don't specify environments</p> <p>If you don't specify any environment, the <code>default</code> environment will be installed and cached, even if you use other environments.</p>"},{"location":"advanced/github_actions/#authentication","title":"Authentication","text":"<p>There are currently three ways to authenticate with pixi:</p> <ul> <li>using a token</li> <li>using a username and password</li> <li>using a conda-token</li> </ul> <p>For more information, see Authentication.</p> <p>Handle secrets with care</p> <p>Please only store sensitive information using GitHub secrets. Do not store them in your repository. When your sensitive information is stored in a GitHub secret, you can access it using the <code>${{ secrets.SECRET_NAME }}</code> syntax. These secrets will always be masked in the logs.</p>"},{"location":"advanced/github_actions/#token","title":"Token","text":"<p>Specify the token using the <code>auth-token</code> input argument. This form of authentication (bearer token in the request headers) is mainly used at prefix.dev.</p> <pre><code>- uses: prefix-dev/setup-pixi@v0.7.0\n  with:\n    auth-host: prefix.dev\n    auth-token: ${{ secrets.PREFIX_DEV_TOKEN }}\n</code></pre>"},{"location":"advanced/github_actions/#username-and-password","title":"Username and password","text":"<p>Specify the username and password using the <code>auth-username</code> and <code>auth-password</code> input arguments. This form of authentication (HTTP Basic Auth) is used in some enterprise environments with artifactory for example.</p> <pre><code>- uses: prefix-dev/setup-pixi@v0.7.0\n  with:\n    auth-host: custom-artifactory.com\n    auth-username: ${{ secrets.PIXI_USERNAME }}\n    auth-password: ${{ secrets.PIXI_PASSWORD }}\n</code></pre>"},{"location":"advanced/github_actions/#conda-token","title":"Conda-token","text":"<p>Specify the conda-token using the <code>conda-token</code> input argument. This form of authentication (token is encoded in URL: <code>https://my-quetz-instance.com/t/&lt;token&gt;/get/custom-channel</code>) is used at anaconda.org or with quetz instances.</p> <pre><code>- uses: prefix-dev/setup-pixi@v0.7.0\n  with:\n    auth-host: anaconda.org # (1)!\n    conda-token: ${{ secrets.CONDA_TOKEN }}\n</code></pre> <ol> <li>or my-quetz-instance.com</li> </ol>"},{"location":"advanced/github_actions/#custom-shell-wrapper","title":"Custom shell wrapper","text":"<p><code>setup-pixi</code> allows you to run command inside of the pixi environment by specifying a custom shell wrapper with <code>shell: pixi run bash -e {0}</code>. This can be useful if you want to run commands inside of the pixi environment, but don't want to use the <code>pixi run</code> command for each command.</p> <pre><code>- run: | # (1)!\n    python --version\n    pip install --no-deps -e .\n  shell: pixi run bash -e {0}\n</code></pre> <ol> <li>everything here will be run inside of the pixi environment</li> </ol> <p>You can even run Python scripts like this:</p> <pre><code>- run: | # (1)!\n    import my_package\n    print(\"Hello world!\")\n  shell: pixi run python {0}\n</code></pre> <ol> <li>everything here will be run inside of the pixi environment</li> </ol> <p>If you want to use PowerShell, you need to specify <code>-Command</code> as well.</p> <pre><code>- run: | # (1)!\n    python --version | Select-String \"3.11\"\n  shell: pixi run pwsh -Command {0} # pwsh works on all platforms\n</code></pre> <ol> <li>everything here will be run inside of the pixi environment</li> </ol> <p>How does it work under the hood?</p> <p>Under the hood, the <code>shell: xyz {0}</code> option is implemented by creating a temporary script file and calling <code>xyz</code> with that script file as an argument. This file does not have the executable bit set, so you cannot use <code>shell: pixi run {0}</code> directly but instead have to use <code>shell: pixi run bash {0}</code>. There are some custom shells provided by GitHub that have slightly different behavior, see <code>jobs.&lt;job_id&gt;.steps[*].shell</code> in the documentation. See the official documentation and ADR 0277 for more information about how the <code>shell:</code> input works in GitHub Actions.</p>"},{"location":"advanced/github_actions/#environment-activation","title":"Environment activation","text":"<p>Instead of using a custom shell wrapper, you can also make all pixi-installed binaries available to subsequent steps by \"activating\" the installed environment in the currently running job. To this end, <code>setup-pixi</code> adds all environment variables set when executing <code>pixi run</code> to <code>$GITHUB_ENV</code> and, similarly, adds all path modifications to <code>$GITHUB_PATH</code>. As a result, all installed binaries can be accessed without having to call <code>pixi run</code>.</p> <pre><code>- uses: prefix-dev/setup-pixi@v0.7.0\n  with:\n    activate-environment: true\n</code></pre> <p>If you are installing multiple environments, you will need to specify the name of the environment that you want to be activated.</p> <pre><code>- uses: prefix-dev/setup-pixi@v0.7.0\n  with:\n    environments: &gt;-\n      py311\n      py312\n    activate-environment: py311\n</code></pre> <p>Activating an environment may be more useful than using a custom shell wrapper as it allows non-shell based steps to access binaries on the path. However, be aware that this option augments the environment of your job.</p>"},{"location":"advanced/github_actions/#-frozen-and-locked","title":"<code>--frozen</code> and <code>--locked</code>","text":"<p>You can specify whether <code>setup-pixi</code> should run <code>pixi install --frozen</code> or <code>pixi install --locked</code> depending on the <code>frozen</code> or the <code>locked</code> input argument. See the official documentation for more information about the <code>--frozen</code> and <code>--locked</code> flags.</p> <pre><code>- uses: prefix-dev/setup-pixi@v0.7.0\n  with:\n    locked: true\n    # or\n    frozen: true\n</code></pre> <p>If you don't specify anything, the default behavior is to run <code>pixi install --locked</code> if a <code>pixi.lock</code> file is present and <code>pixi install</code> otherwise.</p>"},{"location":"advanced/github_actions/#debugging","title":"Debugging","text":"<p>There are two types of debug logging that you can enable.</p>"},{"location":"advanced/github_actions/#debug-logging-of-the-action","title":"Debug logging of the action","text":"<p>The first one is the debug logging of the action itself. This can be enabled by for the action by re-running the action in debug mode:</p> <p> </p> <p>Debug logging documentation</p> <p>For more information about debug logging in GitHub Actions, see the official documentation.</p>"},{"location":"advanced/github_actions/#debug-logging-of-pixi","title":"Debug logging of pixi","text":"<p>The second type is the debug logging of the pixi executable. This can be specified by setting the <code>log-level</code> input.</p> <pre><code>- uses: prefix-dev/setup-pixi@v0.7.0\n  with:\n    log-level: vvv # (1)!\n</code></pre> <ol> <li>One of <code>q</code>, <code>default</code>, <code>v</code>, <code>vv</code>, or <code>vvv</code>.</li> </ol> <p>If nothing is specified, <code>log-level</code> will default to <code>default</code> or <code>vv</code> depending on if debug logging is enabled for the action.</p>"},{"location":"advanced/github_actions/#self-hosted-runners","title":"Self-hosted runners","text":"<p>On self-hosted runners, it may happen that some files are persisted between jobs. This can lead to problems or secrets getting leaked between job runs. To avoid this, you can use the <code>post-cleanup</code> input to specify the post cleanup behavior of the action (i.e., what happens after all your commands have been executed).</p> <p>If you set <code>post-cleanup</code> to <code>true</code>, the action will delete the following files:</p> <ul> <li><code>.pixi</code> environment</li> <li>the pixi binary</li> <li>the rattler cache</li> <li>other rattler files in <code>~/.rattler</code></li> </ul> <p>If nothing is specified, <code>post-cleanup</code> will default to <code>true</code>.</p> <p>On self-hosted runners, you also might want to alter the default pixi install location to a temporary location. You can use <code>pixi-bin-path: ${{ runner.temp }}/bin/pixi</code> to do this.</p> <pre><code>- uses: prefix-dev/setup-pixi@v0.7.0\n  with:\n    post-cleanup: true\n    pixi-bin-path: ${{ runner.temp }}/bin/pixi # (1)!\n</code></pre> <ol> <li><code>${{ runner.temp }}\\Scripts\\pixi.exe</code> on Windows</li> </ol> <p>You can also use a preinstalled local version of pixi on the runner by not setting any of the <code>pixi-version</code>, <code>pixi-url</code> or <code>pixi-bin-path</code> inputs. This action will then try to find a local version of pixi in the runner's PATH.</p>"},{"location":"advanced/github_actions/#using-the-pyprojecttoml-as-a-manifest-file-for-pixi","title":"Using the <code>pyproject.toml</code> as a manifest file for pixi.","text":"<p><code>setup-pixi</code> will automatically pick up the <code>pyproject.toml</code> if it contains a <code>[tool.pixi.project]</code> section and no <code>pixi.toml</code>. This can be overwritten by setting the <code>manifest-path</code> input argument.</p> <pre><code>- uses: prefix-dev/setup-pixi@v0.7.0\n  with:\n    manifest-path: pyproject.toml\n</code></pre>"},{"location":"advanced/github_actions/#more-examples","title":"More examples","text":"<p>If you want to see more examples, you can take a look at the GitHub Workflows of the <code>setup-pixi</code> repository.</p>"},{"location":"advanced/global_configuration/","title":"Global configuration in pixi","text":"<p>Pixi supports some global configuration options, as well as project-scoped configuration (that does not belong into the project file). The configuration is loaded in the following order:</p> <ol> <li>System configuration folder (<code>/etc/pixi/config.toml</code> or <code>C:\\ProgramData\\pixi\\config.toml</code>)</li> <li>XDG compliant configuration folder (<code>$XDG_CONFIG_HOME/pixi/config.toml</code> or    <code>$HOME/.config/pixi/config.toml</code>)</li> <li>Global configuration folder, depending on the OS:<ul> <li>Linux: <code>$HOME/.config/pixi/config.toml</code></li> <li>macOS: <code>$HOME/Library/Application Support/pixi/config.toml</code></li> <li>Windows: <code>%APPDATA%\\pixi\\config.toml</code></li> </ul> </li> <li>Global .pixi folder: <code>~/.pixi/config.toml</code> (or <code>$PIXI_HOME/config.toml</code> if    the <code>PIXI_HOME</code> environment variable is set)</li> <li>Project-local .pixi folder: <code>$PIXI_PROJECT/.pixi/config.toml</code></li> <li>Command line arguments (<code>--tls-no-verify</code>, <code>--change-ps1=false</code> etc.)</li> </ol> <p>Note</p> <p>To find the locations where <code>pixi</code> looks for configuration files, run <code>pixi</code> with <code>-v</code> or <code>--verbose</code>.</p>"},{"location":"advanced/global_configuration/#reference","title":"Reference","text":"Casing In Configuration <p>In versions of pixi <code>0.20.1</code> and older the global configuration used snake_case we've changed to <code>kebab-case</code> for consistency with the rest of the configuration. But we still support the old <code>snake_case</code> configuration, for older configuration options. These are:</p> <ul> <li><code>default_channels</code></li> <li><code>change_ps1</code></li> <li><code>tls_no_verify</code></li> <li><code>authentication_override_file</code></li> <li><code>mirrors</code> and sub-options</li> <li><code>repodata-config</code> and sub-options</li> </ul> <p>The following reference describes all available configuration options.</p> <pre><code># The default channels to select when running `pixi init` or `pixi global install`.\n# This defaults to only conda-forge.\ndefault-channels = [\"conda-forge\"]\n\n# When set to false, the `(pixi)` prefix in the shell prompt is removed.\n# This applies to the `pixi shell` subcommand.\n# You can override this from the CLI with `--change-ps1`.\nchange-ps1 = true\n\n# When set to true, the TLS certificates are not verified. Note that this is a\n# security risk and should only be used for testing purposes or internal networks.\n# You can override this from the CLI with `--tls-no-verify`.\ntls-no-verify = false\n\n# Override from where the authentication information is loaded.\n# Usually we try to use the keyring to load authentication data from, and only use a JSON\n# file as fallback. This option allows you to force the use of a JSON file.\n# Read more in the authentication section.\nauthentication-override-file = \"/path/to/your/override.json\"\n\n# configuration for conda channel-mirrors\n[mirrors]\n# redirect all requests for conda-forge to the prefix.dev mirror\n\"https://conda.anaconda.org/conda-forge\" = [\n    \"https://prefix.dev/conda-forge\"\n]\n\n# redirect all requests for bioconda to one of the three listed mirrors\n# Note: for repodata we try the first mirror first.\n\"https://conda.anaconda.org/bioconda\" = [\n    \"https://conda.anaconda.org/bioconda\",\n    # OCI registries are also supported\n    \"oci://ghcr.io/channel-mirrors/bioconda\",\n    \"https://prefix.dev/bioconda\",\n]\n\n[repodata-config]\n# disable fetching of jlap, bz2 or zstd repodata files.\n# This should only be used for specific old versions of artifactory and other non-compliant\n# servers.\ndisable-jlap = true  # don't try to download repodata.jlap\ndisable-bzip2 = true # don't try to download repodata.json.bz2\ndisable-zstd = true  # don't try to download repodata.json.zst\n\n\n[pypi-config]\n# These are sections specifically related to the PyPI configuration.\nindex-url = \"https://pypi.org/simple\"\nextra-index-urls = [\"https://pypi.org/simple2\"]\nkeyring-provider = \"subprocess\"\n</code></pre>"},{"location":"advanced/global_configuration/#mirror-configuration","title":"Mirror configuration","text":"<p>You can configure mirrors for conda channels. We expect that mirrors are exact copies of the original channel. The implementation will look for the mirror key (a URL) in the <code>mirrors</code> section of the configuration file and replace the original URL with the mirror URL.</p> <p>To also include the original URL, you have to repeat it in the list of mirrors.</p> <p>The mirrors are prioritized based on the order of the list. We attempt to fetch the repodata (the most important file) from the first mirror in the list. The repodata contains all the SHA256 hashes of the individual packages, so it is important to get this file from a trusted source.</p> <p>You can also specify mirrors for an entire \"host\", e.g.</p> <pre><code>[mirrors]\n\"https://conda.anaconda.org\" = [\n    \"https://prefix.dev/\"\n]\n</code></pre> <p>This will forward all request to channels on anaconda.org to prefix.dev. Channels that are not currently mirrored on prefix.dev will fail in the above example.</p>"},{"location":"advanced/global_configuration/#oci-mirrors","title":"OCI Mirrors","text":"<p>You can also specify mirrors on the OCI registry. There is a public mirror on the Github container registry (ghcr.io) that is maintained by the conda-forge team. You can use it like this:</p> <pre><code>[mirrors]\n\"https://conda.anaconda.org/conda-forge\" = [\n    \"oci://ghcr.io/channel-mirrors/conda-forge\"\n]\n</code></pre> <p>The GHCR mirror also contains <code>bioconda</code> packages. You can search the available packages on Github.</p>"},{"location":"advanced/global_configuration/#pypi-configuration","title":"PyPI configuration","text":"<p>To setup a certain number of defaults for the usage of PyPI registries. You can use the following configuration options:</p> <ul> <li><code>index-url</code>: The default index URL to use for PyPI packages. This will be added to a manifest file on a pixi init.</li> <li><code>extra-index-urls</code>: A list of additional URLs to use for PyPI packages. This will be added to a manifest file on a pixi init.</li> <li><code>keyring-provider</code>: Allows the use of the keyring python package to store and retrieve credentials.</li> </ul> <pre><code>[pypi-config]\n# Main index url\nindex-url = \"https://pypi.org/simple\"\n# list of additional urls\nextra-index-urls = [\"https://pypi.org/simple2\"]\n# can be \"subprocess\" or \"disabled\"\nkeyring-provider = \"subprocess\"\n</code></pre> <p><code>index-url</code> and <code>extra-index-urls</code> are not globals</p> <p>Unlike pip, these settings, with the exception of <code>keyring-provider</code> will only modify the <code>pixi.toml</code>/<code>pyproject.toml</code> file and are not globally interpreted when not present in the manifest. This is because we want to keep the manifest file as complete and reproducible as possible.</p>"},{"location":"advanced/pyproject_toml/","title":"<code>pyproject.toml</code> in pixi","text":"<p>We support the use of the <code>pyproject.toml</code> as our manifest file in pixi. This allows the user to keep one file with all configuration. The <code>pyproject.toml</code> file is a standard for Python projects. We don't advise to use the <code>pyproject.toml</code> file for anything else than python projects, the <code>pixi.toml</code> is better suited for other types of projects.</p>"},{"location":"advanced/pyproject_toml/#initial-setup-of-the-pyprojecttoml-file","title":"Initial setup of the <code>pyproject.toml</code> file","text":"<p>When you already have a <code>pyproject.toml</code> file in your project, you can run <code>pixi init</code> in a that folder. Pixi will automatically</p> <ul> <li>Add a <code>[tool.pixi.project]</code> section to the file, with the platform and channel information required by pixi;</li> <li>Add the current project as an editable pypi dependency;</li> <li>Add some defaults to the <code>.gitignore</code> and <code>.gitattributes</code> files.</li> </ul> <p>If you do not have an existing <code>pyproject.toml</code> file , you can run <code>pixi init --pyproject</code> in your project folder. In that case, pixi will create a <code>pyproject.toml</code> manifest from scratch with some sane defaults.</p>"},{"location":"advanced/pyproject_toml/#python-dependency","title":"Python dependency","text":"<p>The <code>pyproject.toml</code> file supports the <code>requires_python</code> field. Pixi understands that field and automatically adds the version to the dependencies.</p> <p>This is an example of a <code>pyproject.toml</code> file with the <code>requires_python</code> field, which will be used as the python dependency:</p> pyproject.toml<pre><code>[project]\nname = \"my_project\"\nrequires-python = \"&gt;=3.9\"\n\n[tool.pixi.project]\nchannels = [\"conda-forge\"]\nplatforms = [\"linux-64\", \"osx-arm64\", \"osx-64\", \"win-64\"]\n</code></pre> <p>Which is equivalent to:</p> equivalent pixi.toml<pre><code>[project]\nname = \"my_project\"\nchannels = [\"conda-forge\"]\nplatforms = [\"linux-64\", \"osx-arm64\", \"osx-64\", \"win-64\"]\n\n[dependencies]\npython = \"&gt;=3.9\"\n</code></pre>"},{"location":"advanced/pyproject_toml/#dependency-section","title":"Dependency section","text":"<p>The <code>pyproject.toml</code> file supports the <code>dependencies</code> field. Pixi understands that field and automatically adds the dependencies to the project as <code>[pypi-dependencies]</code>.</p> <p>This is an example of a <code>pyproject.toml</code> file with the <code>dependencies</code> field:</p> pyproject.toml<pre><code>[project]\nname = \"my_project\"\nrequires-python = \"&gt;=3.9\"\ndependencies = [\n    \"numpy\",\n    \"pandas\",\n    \"matplotlib\",\n]\n\n[tool.pixi.project]\nchannels = [\"conda-forge\"]\nplatforms = [\"linux-64\", \"osx-arm64\", \"osx-64\", \"win-64\"]\n</code></pre> <p>Which is equivalent to:</p> equivalent pixi.toml<pre><code>[project]\nname = \"my_project\"\nchannels = [\"conda-forge\"]\nplatforms = [\"linux-64\", \"osx-arm64\", \"osx-64\", \"win-64\"]\n\n[pypi-dependencies]\nnumpy = \"*\"\npandas = \"*\"\nmatplotlib = \"*\"\n\n[dependencies]\npython = \"&gt;=3.9\"\n</code></pre> <p>You can overwrite these with conda dependencies by adding them to the <code>dependencies</code> field:</p> pyproject.toml<pre><code>[project]\nname = \"my_project\"\nrequires-python = \"&gt;=3.9\"\ndependencies = [\n    \"numpy\",\n    \"pandas\",\n    \"matplotlib\",\n]\n\n[tool.pixi.project]\nchannels = [\"conda-forge\"]\nplatforms = [\"linux-64\", \"osx-arm64\", \"osx-64\", \"win-64\"]\n\n[tool.pixi.dependencies]\nnumpy = \"*\"\npandas = \"*\"\nmatplotlib = \"*\"\n</code></pre> <p>This would result in the conda dependencies being installed and the pypi dependencies being ignored. As pixi takes the conda dependencies over the pypi dependencies.</p>"},{"location":"advanced/pyproject_toml/#optional-dependencies","title":"Optional dependencies","text":"<p>If your python project includes groups of optional dependencies, pixi will automatically interpret them as pixi features of the same name with the associated <code>pypi-dependencies</code>.</p> <p>You can add them to pixi environments manually, or use <code>pixi init</code> to setup the project, which will create one environment per feature. Self-references to other groups of optional dependencies are also handled.</p> <p>For instance, imagine you have a project folder with a <code>pyproject.toml</code> file similar to:</p> <pre><code>[project]\nname = \"my_project\"\ndependencies = [\"package1\"]\n\n[project.optional-dependencies]\ntest = [\"pytest\"]\nall = [\"package2\",\"my_project[test]\"]\n</code></pre> <p>Running <code>pixi init</code> in that project folder will transform the <code>pyproject.toml</code> file into:</p> <pre><code>[project]\nname = \"my_project\"\ndependencies = [\"package1\"]\n\n[project.optional-dependencies]\ntest = [\"pytest\"]\nall = [\"package2\",\"my_project[test]\"]\n\n[tool.pixi.project]\nchannels = [\"conda-forge\"]\nplatforms = [\"linux-64\"] # if executed on linux\n\n[tool.pixi.environments]\ndefault = {features = [], solve-group = \"default\"}\ntest = {features = [\"test\"], solve-group = \"default\"}\nall = {features = [\"all\", \"test\"], solve-group = \"default\"}\n</code></pre> <p>In this example, three environments will be created by pixi:</p> <ul> <li>default with 'package1' as pypi dependency</li> <li>test with 'package1' and 'pytest' as pypi dependencies</li> <li>all with 'package1', 'package2' and 'pytest' as pypi dependencies</li> </ul> <p>All environments will be solved together, as indicated by the common <code>solve-group</code>, and added to the lock file. You can edit the <code>[tool.pixi.environments]</code> section manually to adapt it to your use case (e.g. if you do not need a particular environment).</p>"},{"location":"advanced/pyproject_toml/#example","title":"Example","text":"<p>As the <code>pyproject.toml</code> file supports the full pixi spec with <code>[tool.pixi]</code> prepended an example would look like this:</p> pyproject.toml<pre><code>[project]\nname = \"my_project\"\nrequires-python = \"&gt;=3.9\"\ndependencies = [\n    \"numpy\",\n    \"pandas\",\n    \"matplotlib\",\n    \"ruff\",\n]\n\n[tool.pixi.project]\nchannels = [\"conda-forge\"]\nplatforms = [\"linux-64\", \"osx-arm64\", \"osx-64\", \"win-64\"]\n\n[tool.pixi.dependencies]\ncompilers = \"*\"\ncmake = \"*\"\n\n[tool.pixi.tasks]\nstart = \"python my_project/main.py\"\nlint = \"ruff lint\"\n\n[tool.pixi.system-requirements]\ncuda = \"11.0\"\n\n[tool.pixi.feature.test.dependencies]\npytest = \"*\"\n\n[tool.pixi.feature.test.tasks]\ntest = \"pytest\"\n\n[tool.pixi.environments]\ntest = [\"test\"]\n</code></pre>"},{"location":"advanced/pyproject_toml/#build-system-section","title":"Build-system section","text":"<p>The <code>pyproject.toml</code> file normally contains a <code>[build-system]</code> section. Pixi will use this section to build and install the project if it is added as a pypi path dependency.</p> <p>If the <code>pyproject.toml</code> file does not contain any <code>[build-system]</code> section, pixi will fall back to uv's default, which is equivalent to the below:</p> pyproject.toml<pre><code>[build-system]\nrequires = [\"setuptools &gt;= 40.8.0\"]\nbuild-backend = \"setuptools.build_meta:__legacy__\"\n</code></pre> <p>Including a <code>[build-system]</code> section is highly recommended. If you are not sure of the build-backend you want to use, including the <code>[build-system]</code> section below in your <code>pyproject.toml</code> is a good starting point</p> pyproject.toml<pre><code>[build-system]\nrequires = [\"setuptools\"]\nbuild-backend = \"setuptools.build_meta\"\n</code></pre>"},{"location":"examples/cpp-sdl/","title":"SDL example","text":"<p> The <code>cpp-sdl</code> example is located in the pixi repository.</p> <pre><code>git clone https://github.com/prefix-dev/pixi.git\n</code></pre> <p>Move to the example folder</p> <pre><code>cd pixi/examples/cpp-sdl\n</code></pre> <p>Run the <code>start</code> command</p> <pre><code>pixi run start\n</code></pre> <p>Using the <code>depends-on</code> feature you only needed to run the <code>start</code> task but under water it is running the following tasks.</p> <pre><code># Configure the CMake project\npixi run configure\n\n# Build the executable\npixi run build\n\n# Start the build executable\npixi run start\n</code></pre>"},{"location":"examples/opencv/","title":"Opencv example","text":"<p>The <code>opencv</code> example is located in the pixi repository.</p> <pre><code>git clone https://github.com/prefix-dev/pixi.git\n</code></pre> <p>Move to the example folder</p> <pre><code>cd pixi/examples/opencv\n</code></pre>"},{"location":"examples/opencv/#face-detection","title":"Face detection","text":"<p>Run the <code>start</code> command to start the face detection algorithm.</p> <pre><code>pixi run start\n</code></pre> <p>The screen that starts should look like this: </p> <p>Check out the <code>webcame_capture.py</code> to see how we detect a face.</p>"},{"location":"examples/opencv/#camera-calibration","title":"Camera Calibration","text":"<p>Next to face recognition, a camera calibration example is also included.</p> <p>You'll need a checkerboard for this to work. Print this: </p> <p>Then run</p> <pre><code>pixi run calibrate\n</code></pre> <p>To make a picture for calibration press <code>SPACE</code> Do this approximately 10 times with the chessboard in view of the camera</p> <p>After that press <code>ESC</code> which will start the calibration.</p> <p>When the calibration is done, the camera will be used again to find the distance to the checkerboard.</p> <p></p>"},{"location":"examples/ros2-nav2/","title":"Navigation 2 example","text":"<p>The <code>nav2</code> example is located in the pixi repository.</p> <pre><code>git clone https://github.com/prefix-dev/pixi.git\n</code></pre> <p>Move to the example folder</p> <pre><code>cd pixi/examples/ros2-nav2\n</code></pre> <p>Run the <code>start</code> command</p> <pre><code>pixi run start\n</code></pre>"},{"location":"features/advanced_tasks/","title":"Advanced tasks","text":"<p>When building a package, you often have to do more than just run the code. Steps like formatting, linting, compiling, testing, benchmarking, etc. are often part of a project. With pixi tasks, this should become much easier to do.</p> <p>Here are some quick examples</p> pixi.toml<pre><code>[tasks]\n# Commands as lists so you can also add documentation in between.\nconfigure = { cmd = [\n    \"cmake\",\n    # Use the cross-platform Ninja generator\n    \"-G\",\n    \"Ninja\",\n    # The source is in the root directory\n    \"-S\",\n    \".\",\n    # We wanna build in the .build directory\n    \"-B\",\n    \".build\",\n] }\n\n# Depend on other tasks\nbuild = { cmd = [\"ninja\", \"-C\", \".build\"], depends-on = [\"configure\"] }\n\n# Using environment variables\nrun = \"python main.py $PIXI_PROJECT_ROOT\"\nset = \"export VAR=hello &amp;&amp; echo $VAR\"\n\n# Cross platform file operations\ncopy = \"cp pixi.toml pixi_backup.toml\"\nclean = \"rm pixi_backup.toml\"\nmove = \"mv pixi.toml backup.toml\"\n</code></pre>"},{"location":"features/advanced_tasks/#depends-on","title":"Depends on","text":"<p>Just like packages can depend on other packages, our tasks can depend on other tasks. This allows for complete pipelines to be run with a single command.</p> <p>An obvious example is compiling before running an application.</p> <p>Checkout our <code>cpp_sdl</code> example for a running example. In that package we have some tasks that depend on each other, so we can assure that when you run <code>pixi run start</code> everything is set up as expected.</p> <pre><code>pixi task add configure \"cmake -G Ninja -S . -B .build\"\npixi task add build \"ninja -C .build\" --depends-on configure\npixi task add start \".build/bin/sdl_example\" --depends-on build\n</code></pre> <p>Results in the following lines added to the <code>pixi.toml</code></p> pixi.toml<pre><code>[tasks]\n# Configures CMake\nconfigure = \"cmake -G Ninja -S . -B .build\"\n# Build the executable but make sure CMake is configured first.\nbuild = { cmd = \"ninja -C .build\", depends-on = [\"configure\"] }\n# Start the built executable\nstart = { cmd = \".build/bin/sdl_example\", depends-on = [\"build\"] }\n</code></pre> <pre><code>pixi run start\n</code></pre> <p>The tasks will be executed after each other:</p> <ul> <li>First <code>configure</code> because it has no dependencies.</li> <li>Then <code>build</code> as it only depends on <code>configure</code>.</li> <li>Then <code>start</code> as all it dependencies are run.</li> </ul> <p>If one of the commands fails (exit with non-zero code.) it will stop and the next one will not be started.</p> <p>With this logic, you can also create aliases as you don't have to specify any command in a task.</p> <pre><code>pixi task add fmt ruff\npixi task add lint pylint\n</code></pre> <pre><code>pixi task alias style fmt lint\n</code></pre> <p>Results in the following <code>pixi.toml</code>.</p> pixi.toml<pre><code>fmt = \"ruff\"\nlint = \"pylint\"\nstyle = { depends-on = [\"fmt\", \"lint\"] }\n</code></pre> <p>Now run both tools with one command.</p> <pre><code>pixi run style\n</code></pre>"},{"location":"features/advanced_tasks/#working-directory","title":"Working directory","text":"<p>Pixi tasks support the definition of a working directory.</p> <p><code>cwd</code>\" stands for Current Working Directory. The directory is relative to the pixi package root, where the <code>pixi.toml</code> file is located.</p> <p>Consider a pixi project structured as follows:</p> <pre><code>\u251c\u2500\u2500 pixi.toml\n\u2514\u2500\u2500 scripts\n    \u2514\u2500\u2500 bar.py\n</code></pre> <p>To add a task to run the <code>bar.py</code> file, use:</p> <pre><code>pixi task add bar \"python bar.py\" --cwd scripts\n</code></pre> <p>This will add the following line to manifest file:</p> pixi.toml<pre><code>[tasks]\nbar = { cmd = \"python bar.py\", cwd = \"scripts\" }\n</code></pre>"},{"location":"features/advanced_tasks/#caching","title":"Caching","text":"<p>When you specify <code>inputs</code> and/or <code>outputs</code> to a task, pixi will reuse the result of the task.</p> <p>For the cache, pixi checks that the following are true:</p> <ul> <li>No package in the environment has changed.</li> <li>The selected inputs and outputs are the same as the last time the task was   run. We compute fingerprints of all the files selected by the globs and   compare them to the last time the task was run.</li> <li>The command is the same as the last time the task was run.</li> </ul> <p>If all of these conditions are met, pixi will not run the task again and instead use the existing result.</p> <p>Inputs and outputs can be specified as globs, which will be expanded to all matching files.</p> pixi.toml<pre><code>[tasks]\n# This task will only run if the `main.py` file has changed.\nrun = { cmd = \"python main.py\", inputs = [\"main.py\"] }\n\n# This task will remember the result of the `curl` command and not run it again if the file `data.csv` already exists.\ndownload_data = { cmd = \"curl -o data.csv https://example.com/data.csv\", outputs = [\"data.csv\"] }\n\n# This task will only run if the `src` directory has changed and will remember the result of the `make` command.\nbuild = { cmd = \"make\", inputs = [\"src/*.cpp\", \"include/*.hpp\"], outputs = [\"build/app.exe\"] }\n</code></pre> <p>Note: if you want to debug the globs you can use the <code>--verbose</code> flag to see which files are selected.</p> <pre><code># shows info logs of all files that were selected by the globs\npixi run -v start\n</code></pre>"},{"location":"features/advanced_tasks/#environment-variables","title":"Environment variables","text":"<p>You can set environment variables for a task. These are seen as \"default\" values for the variables as you can overwrite them from the shell.</p> <p>pixi.toml<pre><code>[tasks]\necho = { cmd = \"echo $ARGUMENT\", env = { ARGUMENT = \"hello\" } }\n</code></pre> If you run <code>pixi run echo</code> it will output <code>hello</code>. When you set the environment variable <code>ARGUMENT</code> before running the task, it will use that value instead.</p> <pre><code>ARGUMENT=world pixi run echo\n\u2728 Pixi task (echo in default): echo $ARGUMENT\nworld\n</code></pre> <p>These variables are not shared over tasks, so you need to define these for every task you want to use them in.</p> <p>Extend instead of overwrite</p> <p>If you use the same environment variable in the value as in the key of the map you will also overwrite the variable. For example overwriting a <code>PATH</code> pixi.toml<pre><code>[tasks]\necho = { cmd = \"echo $PATH\", env = { PATH = \"/tmp/path:$PATH\" } }\n</code></pre> This will output <code>/tmp/path:/usr/bin:/bin</code> instead of the original <code>/usr/bin:/bin</code>.</p>"},{"location":"features/advanced_tasks/#our-task-runner-deno_task_shell","title":"Our task runner: deno_task_shell","text":"<p>To support the different OS's (Windows, OSX and Linux), pixi integrates a shell that can run on all of them. This is <code>deno_task_shell</code>. The task shell is a limited implementation of a bourne-shell interface.</p>"},{"location":"features/advanced_tasks/#built-in-commands","title":"Built-in commands","text":"<p>Next to running actual executable like <code>./myprogram</code>, <code>cmake</code> or <code>python</code> the shell has some built-in commandos.</p> <ul> <li><code>cp</code>: Copies files.</li> <li><code>mv</code>: Moves files.</li> <li><code>rm</code>: Remove files or directories.   Ex: <code>rm -rf [FILE]...</code> - Commonly used to recursively delete files or directories.</li> <li><code>mkdir</code>: Makes directories.   Ex. <code>mkdir -p DIRECTORY...</code> - Commonly used to make a directory and all its parents with no error if it exists.</li> <li><code>pwd</code>: Prints the name of the current/working directory.</li> <li><code>sleep</code>: Delays for a specified amount of time.   Ex. <code>sleep 1</code> to sleep for 1 second, <code>sleep 0.5</code> to sleep for half a second, or <code>sleep 1m</code> to sleep a minute</li> <li><code>echo</code>: Displays a line of text.</li> <li><code>cat</code>: Concatenates files and outputs them on stdout. When no arguments are provided, it reads and outputs stdin.</li> <li><code>exit</code>: Causes the shell to exit.</li> <li><code>unset</code>: Unsets environment variables.</li> <li><code>xargs</code>: Builds arguments from stdin and executes a command.</li> </ul>"},{"location":"features/advanced_tasks/#syntax","title":"Syntax","text":"<ul> <li>Boolean list: use <code>&amp;&amp;</code> or <code>||</code> to separate two commands.<ul> <li><code>&amp;&amp;</code>: if the command before <code>&amp;&amp;</code> succeeds continue with the next command.</li> <li><code>||</code>: if the command before <code>||</code> fails continue with the next command.</li> </ul> </li> <li>Sequential lists: use <code>;</code> to run two commands without checking if the first command failed or succeeded.</li> <li>Environment variables:<ul> <li>Set env variable using: <code>export ENV_VAR=value</code></li> <li>Use env variable using: <code>$ENV_VAR</code></li> <li>unset env variable using <code>unset ENV_VAR</code></li> </ul> </li> <li>Shell variables: Shell variables are similar to environment variables, but won\u2019t be exported to spawned commands.<ul> <li>Set them: <code>VAR=value</code></li> <li>use them: <code>VAR=value &amp;&amp; echo $VAR</code></li> </ul> </li> <li>Pipelines: Use the stdout output of a command into the stdin a following command<ul> <li><code>|</code>: <code>echo Hello | python receiving_app.py</code></li> <li><code>|&amp;</code>: use this to also get the stderr as input.</li> </ul> </li> <li>Command substitution: <code>$()</code> to use the output of a command as input for another command.<ul> <li><code>python main.py $(git rev-parse HEAD)</code></li> </ul> </li> <li>Negate exit code: <code>!</code> before any command will negate the exit code from 1 to 0 or visa-versa.</li> <li>Redirects: <code>&gt;</code> to redirect the stdout to a file.<ul> <li><code>echo hello &gt; file.txt</code> will put <code>hello</code> in <code>file.txt</code> and overwrite existing text.</li> <li><code>python main.py 2&gt; file.txt</code> will put the <code>stderr</code> output in <code>file.txt</code>.</li> <li><code>python main.py &amp;&gt; file.txt</code> will put the <code>stderr</code> and <code>stdout</code> in <code>file.txt</code>.</li> <li><code>echo hello &gt; file.txt</code> will append <code>hello</code> to the existing <code>file.txt</code>.</li> </ul> </li> <li>Glob expansion: <code>*</code> to expand all options.<ul> <li><code>echo *.py</code> will echo all filenames that end with <code>.py</code></li> <li><code>echo **/*.py</code> will echo all filenames that end with <code>.py</code> in this directory and all descendant directories.</li> <li><code>echo data[0-9].csv</code> will echo all filenames that have a single number after <code>data</code> and before <code>.csv</code></li> </ul> </li> </ul> <p>More info in <code>deno_task_shell</code> documentation.</p>"},{"location":"features/environment/","title":"Environments","text":"<p>Pixi is a tool to manage virtual environments. This document explains what an environment looks like and how to use it.</p>"},{"location":"features/environment/#structure","title":"Structure","text":"<p>A pixi environment is located in the <code>.pixi/envs</code> directory of the project. This location is not configurable as it is a specific design decision to keep the environments in the project directory. This keeps your machine and your project clean and isolated from each other, and makes it easy to clean up after a project is done.</p> <p>If you look at the <code>.pixi/envs</code> directory, you will see a directory for each environment, the <code>default</code> being the one that is normally used, if you specify a custom environment the name you specified will be used.</p> <pre><code>.pixi\n\u2514\u2500\u2500 envs\n    \u251c\u2500\u2500 cuda\n    \u2502   \u251c\u2500\u2500 bin\n    \u2502   \u251c\u2500\u2500 conda-meta\n    \u2502   \u251c\u2500\u2500 etc\n    \u2502   \u251c\u2500\u2500 include\n    \u2502   \u251c\u2500\u2500 lib\n    \u2502   ...\n    \u2514\u2500\u2500 default\n        \u251c\u2500\u2500 bin\n        \u251c\u2500\u2500 conda-meta\n        \u251c\u2500\u2500 etc\n        \u251c\u2500\u2500 include\n        \u251c\u2500\u2500 lib\n        ...\n</code></pre> <p>These directories are conda environments, and you can use them as such, but you cannot manually edit them, this should always go through the <code>pixi.toml</code>. Pixi will always make sure the environment is in sync with the <code>pixi.lock</code> file. If this is not the case then all the commands that use the environment will automatically update the environment, e.g. <code>pixi run</code>, <code>pixi shell</code>.</p>"},{"location":"features/environment/#cleaning-up","title":"Cleaning up","text":"<p>If you want to clean up the environments, you can simply delete the <code>.pixi/envs</code> directory, and pixi will recreate the environments when needed.</p> <pre><code># either:\nrm -rf .pixi/envs\n\n# or per environment:\nrm -rf .pixi/envs/default\nrm -rf .pixi/envs/cuda\n</code></pre>"},{"location":"features/environment/#activation","title":"Activation","text":"<p>An environment is nothing more than a set of files that are installed into a certain location, that somewhat mimics a global system install. You need to activate the environment to use it. In the most simple sense that mean adding the <code>bin</code> directory of the environment to the <code>PATH</code> variable. But there is more to it in a conda environment, as it also sets some environment variables.</p> <p>To do the activation we have multiple options:</p> <ul> <li>Use the <code>pixi shell</code> command to open a shell with the environment activated.</li> <li>Use the <code>pixi shell-hook</code> command to print the command to activate the environment in your current shell.</li> <li>Use the <code>pixi run</code> command to run a command in the environment.</li> </ul> <p>Where the <code>run</code> command is special as it runs its own cross-platform shell and has the ability to run tasks. More information about tasks can be found in the tasks documentation.</p> <p>Using the <code>pixi shell-hook</code> in pixi you would get the following output:</p> <pre><code>export PATH=\"/home/user/development/pixi/.pixi/envs/default/bin:/home/user/.local/bin:/home/user/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/home/user/.pixi/bin\"\nexport CONDA_PREFIX=\"/home/user/development/pixi/.pixi/envs/default\"\nexport PIXI_PROJECT_NAME=\"pixi\"\nexport PIXI_PROJECT_ROOT=\"/home/user/development/pixi\"\nexport PIXI_PROJECT_VERSION=\"0.12.0\"\nexport PIXI_PROJECT_MANIFEST=\"/home/user/development/pixi/pixi.toml\"\nexport CONDA_DEFAULT_ENV=\"pixi\"\nexport PIXI_ENVIRONMENT_PLATFORMS=\"osx-64,linux-64,win-64,osx-arm64\"\nexport PIXI_ENVIRONMENT_NAME=\"default\"\nexport PIXI_PROMPT=\"(pixi) \"\n. \"/home/user/development/pixi/.pixi/envs/default/etc/conda/activate.d/activate-binutils_linux-64.sh\"\n. \"/home/user/development/pixi/.pixi/envs/default/etc/conda/activate.d/activate-gcc_linux-64.sh\"\n. \"/home/user/development/pixi/.pixi/envs/default/etc/conda/activate.d/activate-gfortran_linux-64.sh\"\n. \"/home/user/development/pixi/.pixi/envs/default/etc/conda/activate.d/activate-gxx_linux-64.sh\"\n. \"/home/user/development/pixi/.pixi/envs/default/etc/conda/activate.d/libglib_activate.sh\"\n. \"/home/user/development/pixi/.pixi/envs/default/etc/conda/activate.d/rust.sh\"\n</code></pre> <p>It sets the <code>PATH</code> and some more environment variables. But more importantly it also runs activation scripts that are presented by the installed packages. An example of this would be the <code>libglib_activate.sh</code> script. Thus, just adding the <code>bin</code> directory to the <code>PATH</code> is not enough.</p>"},{"location":"features/environment/#traditional-conda-activate-like-activation","title":"Traditional <code>conda activate</code>-like activation","text":"<p>If you prefer to use the traditional <code>conda activate</code>-like activation, you could use the <code>pixi shell-hook</code> command.</p> <pre><code>$ which python\npython not found\n$ eval \"$(pixi shell-hook)\"\n$ (default) which python\n/path/to/project/.pixi/envs/default/bin/python\n</code></pre> <p>Warning</p> <p>It is not encouraged to use the traditional <code>conda activate</code>-like activation, as deactivating the environment is not really possible. Use <code>pixi shell</code> instead.</p>"},{"location":"features/environment/#using-pixi-with-direnv","title":"Using <code>pixi</code> with <code>direnv</code>","text":"Installing direnv <p>Of course you can use <code>pixi</code> to install <code>direnv</code> globally. We recommend to run</p> <p><code>pixi global install direnv</code></p> <p>to install the latest version of <code>direnv</code> on your computer.</p> <p>This allows you to use <code>pixi</code> in combination with <code>direnv</code>. Enter the following into your <code>.envrc</code> file:</p> .envrc<pre><code>watch_file pixi.lock # (1)!\neval \"$(pixi shell-hook)\" # (2)!\n</code></pre> <ol> <li>This ensures that every time your <code>pixi.lock</code> changes, <code>direnv</code> invokes the shell-hook again.</li> <li>This installs if needed, and activates the environment. <code>direnv</code> ensures that the environment is deactivated when you leave the directory.</li> </ol> <pre><code>$ cd my-project\ndirenv: error /my-project/.envrc is blocked. Run `direnv allow` to approve its content\n$ direnv allow\ndirenv: loading /my-project/.envrc\n\u2714 Project in /my-project is ready to use!\ndirenv: export +CONDA_DEFAULT_ENV +CONDA_PREFIX +PIXI_ENVIRONMENT_NAME +PIXI_ENVIRONMENT_PLATFORMS +PIXI_PROJECT_MANIFEST +PIXI_PROJECT_NAME +PIXI_PROJECT_ROOT +PIXI_PROJECT_VERSION +PIXI_PROMPT ~PATH\n$ which python\n/my-project/.pixi/envs/default/bin/python\n$ cd ..\ndirenv: unloading\n$ which python\npython not found\n</code></pre>"},{"location":"features/environment/#environment-variables","title":"Environment variables","text":"<p>The following environment variables are set by pixi, when using the <code>pixi run</code>, <code>pixi shell</code>, or <code>pixi shell-hook</code> command:</p> <ul> <li><code>PIXI_PROJECT_ROOT</code>: The root directory of the project.</li> <li><code>PIXI_PROJECT_NAME</code>: The name of the project.</li> <li><code>PIXI_PROJECT_MANIFEST</code>: The path to the manifest file (<code>pixi.toml</code>).</li> <li><code>PIXI_PROJECT_VERSION</code>: The version of the project.</li> <li><code>PIXI_PROMPT</code>: The prompt to use in the shell, also used by <code>pixi shell</code> itself.</li> <li><code>PIXI_ENVIRONMENT_NAME</code>: The name of the environment, defaults to <code>default</code>.</li> <li><code>PIXI_ENVIRONMENT_PLATFORMS</code>: The path to the environment.</li> <li><code>CONDA_PREFIX</code>: The path to the environment. (Used by multiple tools that already understand conda environments)</li> <li><code>CONDA_DEFAULT_ENV</code>: The name of the environment. (Used by multiple tools that already understand conda environments)</li> <li><code>PATH</code>: We prepend the <code>bin</code> directory of the environment to the <code>PATH</code> variable, so you can use the tools installed in the environment directly.</li> </ul> <p>Note</p> <p>Even though the variables are environment variables these cannot be overridden. E.g. you can not change the root of the project by setting <code>PIXI_PROJECT_ROOT</code> in the environment.</p>"},{"location":"features/environment/#solving-environments","title":"Solving environments","text":"<p>When you run a command that uses the environment, pixi will check if the environment is in sync with the <code>pixi.lock</code> file. If it is not, pixi will solve the environment and update it. This means that pixi will retrieve the best set of packages for the dependency requirements that you specified in the <code>pixi.toml</code> and will put the output of the solve step into the <code>pixi.lock</code> file. Solving is a mathematical problem and can take some time, but we take pride in the way we solve environments, and we are confident that we can solve your environment in a reasonable time. If you want to learn more about the solving process, you can read these:</p> <ul> <li>Rattler(conda) resolver blog</li> <li>Rip(PyPI) resolver blog</li> </ul> <p>Pixi solves both the <code>conda</code> and <code>PyPI</code> dependencies, where the <code>PyPI</code> dependencies use the conda packages as a base, so you can be sure that the packages are compatible with each other. These solvers are split between the <code>rattler</code> and <code>rip</code> library, these control the heavy lifting of the solving process, which is executed by our custom SAT solver: <code>resolvo</code>. <code>resolve</code> is able to solve multiple ecosystem like <code>conda</code> and <code>PyPI</code>. It implements the lazy solving process for <code>PyPI</code> packages, which means that it only downloads the metadata of the packages that are needed to solve the environment. It also supports the <code>conda</code> way of solving, which means that it downloads the metadata of all the packages at once and then solves in one go.</p> <p>For the <code>[pypi-dependencies]</code>, <code>rip</code> implements <code>sdist</code> building to retrieve the metadata of the packages, and <code>wheel</code> building to install the packages. For this building step, <code>pixi</code> requires to first install <code>python</code> in the (conda)<code>[dependencies]</code> section of the <code>pixi.toml</code> file. This will always be slower than the pure conda solves. So for the best pixi experience you should stay within the <code>[dependencies]</code> section of the <code>pixi.toml</code> file.</p>"},{"location":"features/environment/#caching","title":"Caching","text":"<p>Pixi caches the packages used in the environment. So if you have multiple projects that use the same packages, pixi will only download the packages once.</p> <p>The cache is located in the <code>~/.cache/rattler/cache</code> directory by default. This location is configurable by setting the <code>PIXI_CACHE_DIR</code> or <code>RATTLER_CACHE_DIR</code> environment variable.</p> <p>When you want to clean the cache, you can simply delete the cache directory, and pixi will re-create the cache when needed.</p>"},{"location":"features/lockfile/","title":"The <code>pixi.lock</code> lock file","text":"<p>A lock file is the protector of the environments, and pixi is the key to unlock it.</p>"},{"location":"features/lockfile/#what-is-a-lock-file","title":"What is a lock file?","text":"<p>A lock file locks the environment in a specific state. Within pixi a lock file is a description of the packages in an environment. The lock file contains two definitions:</p> <ul> <li> <p>The environments that are used in the project with their complete set of packages. e.g.:</p> <pre><code>environments:\n    default:\n        channels:\n          - url: https://conda.anaconda.org/conda-forge/\n        packages:\n            linux-64:\n            ...\n            - conda: https://conda.anaconda.org/conda-forge/linux-64/python-3.12.2-hab00c5b_0_cpython.conda\n            ...\n            osx-64:\n            ...\n            - conda: https://conda.anaconda.org/conda-forge/osx-64/python-3.12.2-h9f0c242_0_cpython.conda\n            ...\n</code></pre> <ul> <li> <p>The definition of the packages themselves. e.g.:</p> <pre><code>- kind: conda\n  name: python\n  version: 3.12.2\n  build: h9f0c242_0_cpython\n  subdir: osx-64\n  url: https://conda.anaconda.org/conda-forge/osx-64/python-3.12.2-h9f0c242_0_cpython.conda\n  sha256: 7647ac06c3798a182a4bcb1ff58864f1ef81eb3acea6971295304c23e43252fb\n  md5: 0179b8007ba008cf5bec11f3b3853902\n  depends:\n    - bzip2 &gt;=1.0.8,&lt;2.0a0\n    - libexpat &gt;=2.5.0,&lt;3.0a0\n    - libffi &gt;=3.4,&lt;4.0a0\n    - libsqlite &gt;=3.45.1,&lt;4.0a0\n    - libzlib &gt;=1.2.13,&lt;1.3.0a0\n    - ncurses &gt;=6.4,&lt;7.0a0\n    - openssl &gt;=3.2.1,&lt;4.0a0\n    - readline &gt;=8.2,&lt;9.0a0\n    - tk &gt;=8.6.13,&lt;8.7.0a0\n    - tzdata\n    - xz &gt;=5.2.6,&lt;6.0a0\n  constrains:\n    - python_abi 3.12.* *_cp312\n  license: Python-2.0\n  size: 14596811\n  timestamp: 1708118065292\n</code></pre> </li> </ul> </li> </ul>"},{"location":"features/lockfile/#why-a-lock-file","title":"Why a lock file","text":"<p>Pixi uses the lock file for the following reasons:</p> <ul> <li>To save a working installation state, without copying the entire environment's data.</li> <li>To ensure the project configuration is aligned with the installed environment.</li> <li>To give the user a file that contains all the information about the environment.</li> </ul> <p>This gives you (and your collaborators) a way to really reproduce the environment they are working in. Using tools such as docker suddenly becomes much less necessary.</p>"},{"location":"features/lockfile/#when-is-a-lock-file-generated","title":"When is a lock file generated?","text":"<p>A lock file is generated when you install a package. More specifically, a lock file is generated from the solve step of the installation process. The solve will return a list of packages that are to be installed, and the lock file will be generated from this list. This diagram tries to explain the process:</p> <pre><code>graph TD\n    A[Install] --&gt; B[Solve]\n    B --&gt; C[Generate and write lock file]\n    C --&gt; D[Install Packages]</code></pre>"},{"location":"features/lockfile/#how-to-use-a-lock-file","title":"How to use a lock file","text":"<p>Do not edit the lock file</p> <p>A lock file is a machine only file, and should not be edited by hand.</p> <p>That said, the <code>pixi.lock</code> is human-readable, so it's easy to track the changes in the environment. We recommend you track the lock file in <code>git</code> or other version control systems. This will ensure that the environment is always reproducible and that you can always revert back to a working state, in case something goes wrong. The <code>pixi.lock</code> and the manifest file <code>pixi.toml</code>/<code>pyproject.toml</code> should always be in sync.</p> <p>Running the following commands will check and automatically update the lock file if you changed any dependencies:</p> <ul> <li><code>pixi install</code></li> <li><code>pixi run</code></li> <li><code>pixi shell</code></li> <li><code>pixi shell-hook</code></li> <li><code>pixi tree</code></li> <li><code>pixi list</code></li> <li><code>pixi add</code></li> <li><code>pixi remove</code></li> </ul> <p>All the commands that support the interaction with the lock file also include some lock file usage options:</p> <ul> <li><code>--frozen</code>: install the environment as defined in the lock file, doesn't update <code>pixi.lock</code> if it isn't up-to-date with manifest file. It can also be controlled by the <code>PIXI_FROZEN</code> environment variable (example: <code>PIXI_FROZEN=true</code>).</li> <li><code>--locked</code>: only install if the <code>pixi.lock</code> is up-to-date with the manifest file[^1]. It can also be controlled by the <code>PIXI_LOCKED</code> environment variable (example: <code>PIXI_LOCKED=true</code>). Conflicts with <code>--frozen</code>.</li> </ul> <p>Syncing the lock file with the manifest file</p> <p>The lock file is always matched with the whole configuration in the manifest file. This means that if you change the manifest file, the lock file will be updated. <pre><code>flowchart TD\n    C[manifest] --&gt; A[lockfile] --&gt; B[environment]</code></pre></p>"},{"location":"features/lockfile/#lockfile-satisfiability","title":"Lockfile satisfiability","text":"<p>The lock file is a description of the environment, and it should always be satisfiable. Satisfiable means that the given manifest file and the created environment are in sync with the lockfile. If the lock file is not satisfiable, pixi will generate a new lock file automatically.</p> <p>Steps to check if the lock file is satisfiable:</p> <ul> <li>All <code>environments</code> in the manifest file are in the lock file</li> <li>All <code>channels</code> in the manifest file are in the lock file</li> <li>All <code>packages</code> in the manifest file are in the lock file, and the versions in the lock file are compatible with the requirements in the manifest file, for both <code>conda</code> and <code>pypi</code> packages.<ul> <li>Conda packages use a <code>matchspec</code> which can match on all the information we store in the lockfile, even <code>timestamp</code>, <code>subdir</code> and <code>license</code>.</li> </ul> </li> <li>If <code>pypi-dependecies</code> are added, all <code>conda</code> package that are python packages in the lock file have a <code>purls</code> field.</li> <li>All hashes for the <code>pypi</code> editable packages are correct.</li> <li>There is only a single entry for every package in the lock file.</li> </ul> <p>If you want to get more details checkout the actual code as this is a simplification of the actual code.</p>"},{"location":"features/lockfile/#the-version-of-the-lock-file","title":"The version of the lock file","text":"<p>The lock file has a version number, this is to ensure that the lock file is compatible with the local version of <code>pixi</code>.</p> <pre><code>version: 4\n</code></pre> <p>Pixi is backward compatible with the lock file, but not forward compatible. This means that you can use an older lock file with a newer version of <code>pixi</code>, but not the other way around.</p>"},{"location":"features/lockfile/#your-lock-file-is-big","title":"Your lock file is big","text":"<p>The lock file can grow quite large, especially if you have a lot of packages installed. This is because the lock file contains all the information about the packages.</p> <ol> <li>We try to keep the lock file as small as possible.</li> <li>It's always smaller than a docker image.</li> <li>Downloading the lock file is always faster than downloading the incorrect packages.</li> </ol>"},{"location":"features/lockfile/#you-dont-need-a-lock-file-because","title":"You don't need a lock file because...","text":"<p>If you can not think of a case where you would benefit from a fast reproducible environment, then you don't need a lock file.</p> <p>But take note of the following:</p> <ul> <li>A lock file allows you to run the same environment on different machines, think CI systems.</li> <li>It also allows you to go back to a working state if you have made a mistake.</li> <li>It helps other users onboard to your project as they don't have to figure out the environment setup or solve dependency issues.</li> </ul>"},{"location":"features/lockfile/#removing-the-lock-file","title":"Removing the lock file","text":"<p>If you want to remove the lock file, you can simply delete it.</p> <pre><code>rm pixi.lock\n</code></pre> <p>This will remove the lock file, and the next time you run a command that requires the lock file, it will be generated again.</p> <p>Note</p> <p>This does remove the locked state of the environment, and the environment will be updated to the latest version of the packages.</p>"},{"location":"features/multi_environment/","title":"Multi Environment Support","text":""},{"location":"features/multi_environment/#motivating-example","title":"Motivating Example","text":"<p>There are multiple scenarios where multiple environments are useful.</p> <ul> <li>Testing of multiple package versions, e.g. <code>py39</code> and <code>py310</code> or polars <code>0.12</code> and <code>0.13</code>.</li> <li>Smaller single tool environments, e.g. <code>lint</code> or <code>docs</code>.</li> <li>Large developer environments, that combine all the smaller environments, e.g. <code>dev</code>.</li> <li>Strict supersets of environments, e.g. <code>prod</code> and <code>test-prod</code> where <code>test-prod</code> is a strict superset of <code>prod</code>.</li> <li>Multiple machines from one project, e.g. a <code>cuda</code> environment and a <code>cpu</code> environment.</li> <li>And many more. (Feel free to edit this document in our GitHub and add your use case.)</li> </ul> <p>This prepares <code>pixi</code> for use in large projects with multiple use-cases, multiple developers and different CI needs.</p>"},{"location":"features/multi_environment/#design-considerations","title":"Design Considerations","text":"<p>There are a few things we wanted to keep in mind in the design:</p> <ol> <li>User-friendliness: Pixi is a user focussed tool that goes beyond developers. The feature should have good error reporting and helpful documentation from the start.</li> <li>Keep it simple: Not understanding the multiple environments feature shouldn't limit a user to use pixi. The feature should be \"invisible\" to the non-multi env use-cases.</li> <li>No Automatic Combinatorial: To ensure the dependency resolution process remains manageable, the solution should avoid a combinatorial explosion of dependency sets. By making the environments user defined and not automatically inferred by testing a matrix of the features.</li> <li>Single environment Activation: The design should allow only one environment to be active at any given time, simplifying the resolution process and preventing conflicts.</li> <li>Fixed lock files: It's crucial to preserve fixed lock files for consistency and predictability. Solutions must ensure reliability not just for authors but also for end-users, particularly at the time of lock file creation.</li> </ol>"},{"location":"features/multi_environment/#feature-environment-set-definitions","title":"Feature &amp; Environment Set Definitions","text":"<p>Introduce environment sets into the <code>pixi.toml</code> this describes environments based on <code>feature</code>'s. Introduce features into the <code>pixi.toml</code> that can describe parts of environments. As an environment goes beyond just <code>dependencies</code> the <code>features</code> should be described including the following fields:</p> <ul> <li><code>dependencies</code>: The conda package dependencies</li> <li><code>pypi-dependencies</code>: The pypi package dependencies</li> <li><code>system-requirements</code>: The system requirements of the environment</li> <li><code>activation</code>: The activation information for the environment</li> <li><code>platforms</code>: The platforms the environment can be run on.</li> <li><code>channels</code>: The channels used to create the environment. Adding the <code>priority</code> field to the channels to allow concatenation of channels instead of overwriting.</li> <li><code>target</code>: All the above features but also separated by targets.</li> <li><code>tasks</code>: Feature specific tasks, tasks in one environment are selected as default tasks for the environment.</li> </ul> Default features<pre><code>[dependencies] # short for [feature.default.dependencies]\npython = \"*\"\nnumpy = \"==2.3\"\n\n[pypi-dependencies] # short for [feature.default.pypi-dependencies]\npandas = \"*\"\n\n[system-requirements] # short for [feature.default.system-requirements]\nlibc = \"2.33\"\n\n[activation] # short for [feature.default.activation]\nscripts = [\"activate.sh\"]\n</code></pre> Different dependencies per feature<pre><code>[feature.py39.dependencies]\npython = \"~=3.9.0\"\n[feature.py310.dependencies]\npython = \"~=3.10.0\"\n[feature.test.dependencies]\npytest = \"*\"\n</code></pre> Full set of environment modification in one feature<pre><code>[feature.cuda]\ndependencies = {cuda = \"x.y.z\", cudnn = \"12.0\"}\npypi-dependencies = {torch = \"1.9.0\"}\nplatforms = [\"linux-64\", \"osx-arm64\"]\nactivation = {scripts = [\"cuda_activation.sh\"]}\nsystem-requirements = {cuda = \"12\"}\n# Channels concatenate using a priority instead of overwrite, so the default channels are still used.\n# Using the priority the concatenation is controlled, default is 0, the default channels are used last.\n# Highest priority comes first.\nchannels = [\"nvidia\", {channel = \"pytorch\", priority = -1}] # Results in:  [\"nvidia\", \"conda-forge\", \"pytorch\"] when the default is `conda-forge`\ntasks = { warmup = \"python warmup.py\" }\ntarget.osx-arm64 = {dependencies = {mlx = \"x.y.z\"}}\n</code></pre> Define tasks as defaults of an environment<pre><code>[feature.test.tasks]\ntest = \"pytest\"\n\n[environments]\ntest = [\"test\"]\n\n# `pixi run test` == `pixi run --environment test test`\n</code></pre> <p>The environment definition should contain the following fields:</p> <ul> <li><code>features: Vec&lt;Feature&gt;</code>: The features that are included in the environment set, which is also the default field in the environments.</li> <li><code>solve-group: String</code>: The solve group is used to group environments together at the solve stage.   This is useful for environments that need to have the same dependencies but might extend them with additional dependencies.   For instance when testing a production environment with additional test dependencies.</li> </ul> Creating environments from features<pre><code>[environments]\n# implicit: default = [\"default\"]\ndefault = [\"py39\"] # implicit: default = [\"py39\", \"default\"]\npy310 = [\"py310\"] # implicit: py310 = [\"py310\", \"default\"]\ntest = [\"test\"] # implicit: test = [\"test\", \"default\"]\ntest39 = [\"test\", \"py39\"] # implicit: test39 = [\"test\", \"py39\", \"default\"]\n</code></pre> Testing a production environment with additional dependencies<pre><code>[environments]\n# Creating a `prod` environment which is the minimal set of dependencies used for production.\nprod = {features = [\"py39\"], solve-group = \"prod\"}\n# Creating a `test_prod` environment which is the `prod` environment plus the `test` feature.\ntest_prod = {features = [\"py39\", \"test\"], solve-group = \"prod\"}\n# Using the `solve-group` to solve the `prod` and `test_prod` environments together\n# Which makes sure the tested environment has the same version of the dependencies as the production environment.\n</code></pre> Creating environments without including the default feature<pre><code>[dependencies]\npython = \"*\"\nnumpy = \"*\"\n\n[feature.lint.dependencies]\npre-commit = \"*\"\n\n[environments]\n# Create a custom environment which only has the `lint` feature (numpy isn't part of that env).\nlint = {features = [\"lint\"], no-default-feature = true}\n</code></pre>"},{"location":"features/multi_environment/#lock-file-structure","title":"lock file Structure","text":"<p>Within the <code>pixi.lock</code> file, a package may now include an additional <code>environments</code> field, specifying the environment to which it belongs. To avoid duplication the packages <code>environments</code> field may contain multiple environments so the lock file is of minimal size.</p> <pre><code>- platform: linux-64\n  name: pre-commit\n  version: 3.3.3\n  category: main\n  environments:\n    - dev\n    - test\n    - lint\n  ...:\n- platform: linux-64\n  name: python\n  version: 3.9.3\n  category: main\n  environments:\n    - dev\n    - test\n    - lint\n    - py39\n    - default\n  ...:\n</code></pre>"},{"location":"features/multi_environment/#user-interface-environment-activation","title":"User Interface Environment Activation","text":"<p>Users can manually activate the desired environment via command line or configuration. This approach guarantees a conflict-free environment by allowing only one feature set to be active at a time. For the user the cli would look like this:</p> Default behavior<pre><code>pixi run python\n# Runs python in the `default` environment\n</code></pre> Activating an specific environment<pre><code>pixi run -e test pytest\npixi run --environment test pytest\n# Runs `pytest` in the `test` environment\n</code></pre> Activating a shell in an environment<pre><code>pixi shell -e cuda\npixi shell --environment cuda\n# Starts a shell in the `cuda` environment\n</code></pre> Running any command in an environment<pre><code>pixi run -e test any_command\n# Runs any_command in the `test` environment which doesn't require to be predefined as a task.\n</code></pre> Interactive selection of environments if task is in multiple environments<pre><code># In the scenario where test is a task in multiple environments, interactive selection should be used.\npixi run test\n# Which env?\n# 1. test\n# 2. test39\n</code></pre>"},{"location":"features/multi_environment/#important-links","title":"Important links","text":"<ul> <li>Initial writeup of the proposal: GitHub Gist by 0xbe7a</li> <li>GitHub project: #10</li> </ul>"},{"location":"features/multi_environment/#real-world-example-use-cases","title":"Real world example use cases","text":"Polarify test setup <p>In <code>polarify</code> they want to test multiple versions combined with multiple versions of polars. This is currently done by using a matrix in GitHub actions. This can be replaced by using multiple environments.</p> pixi.toml<pre><code>[project]\nname = \"polarify\"\n# ...\nchannels = [\"conda-forge\"]\nplatforms = [\"linux-64\", \"osx-arm64\", \"osx-64\", \"win-64\"]\n\n[tasks]\npostinstall = \"pip install --no-build-isolation --no-deps --disable-pip-version-check -e .\"\n\n[dependencies]\npython = \"&gt;=3.9\"\npip = \"*\"\npolars = \"&gt;=0.14.24,&lt;0.21\"\n\n[feature.py39.dependencies]\npython = \"3.9.*\"\n[feature.py310.dependencies]\npython = \"3.10.*\"\n[feature.py311.dependencies]\npython = \"3.11.*\"\n[feature.py312.dependencies]\npython = \"3.12.*\"\n[feature.pl017.dependencies]\npolars = \"0.17.*\"\n[feature.pl018.dependencies]\npolars = \"0.18.*\"\n[feature.pl019.dependencies]\npolars = \"0.19.*\"\n[feature.pl020.dependencies]\npolars = \"0.20.*\"\n\n[feature.test.dependencies]\npytest = \"*\"\npytest-md = \"*\"\npytest-emoji = \"*\"\nhypothesis = \"*\"\n[feature.test.tasks]\ntest = \"pytest\"\n\n[feature.lint.dependencies]\npre-commit = \"*\"\n[feature.lint.tasks]\nlint = \"pre-commit run --all\"\n\n[environments]\npl017 = [\"pl017\", \"py39\", \"test\"]\npl018 = [\"pl018\", \"py39\", \"test\"]\npl019 = [\"pl019\", \"py39\", \"test\"]\npl020 = [\"pl020\", \"py39\", \"test\"]\npy39 = [\"py39\", \"test\"]\npy310 = [\"py310\", \"test\"]\npy311 = [\"py311\", \"test\"]\npy312 = [\"py312\", \"test\"]\n</code></pre> .github/workflows/test.yml<pre><code>jobs:\n  tests-per-env:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        environment: [py311, py312]\n    steps:\n    - uses: actions/checkout@v4\n      - uses: prefix-dev/setup-pixi@v0.5.1\n        with:\n          environments: ${{ matrix.environment }}\n      - name: Run tasks\n        run: |\n          pixi run --environment ${{ matrix.environment }} test\n  tests-with-multiple-envs:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n    - uses: prefix-dev/setup-pixi@v0.5.1\n      with:\n       environments: pl017 pl018\n    - run: |\n        pixi run -e pl017 test\n        pixi run -e pl018 test\n</code></pre> Test vs Production example <p>This is an example of a project that has a <code>test</code> feature and <code>prod</code> environment. The <code>prod</code> environment is a production environment that contains the run dependencies. The <code>test</code> feature is a set of dependencies and tasks that we want to put on top of the previously solved <code>prod</code> environment. This is a common use case where we want to test the production environment with additional dependencies.</p> <p>pixi.toml<pre><code>[project]\nname = \"my-app\"\n# ...\nchannels = [\"conda-forge\"]\nplatforms = [\"osx-arm64\", \"linux-64\"]\n\n[tasks]\npostinstall-e = \"pip install --no-build-isolation --no-deps --disable-pip-version-check -e .\"\npostinstall = \"pip install --no-build-isolation --no-deps --disable-pip-version-check .\"\ndev = \"uvicorn my_app.app:main --reload\"\nserve = \"uvicorn my_app.app:main\"\n\n[dependencies]\npython = \"&gt;=3.12\"\npip = \"*\"\npydantic = \"&gt;=2\"\nfastapi = \"&gt;=0.105.0\"\nsqlalchemy = \"&gt;=2,&lt;3\"\nuvicorn = \"*\"\naiofiles = \"*\"\n\n[feature.test.dependencies]\npytest = \"*\"\npytest-md = \"*\"\npytest-asyncio = \"*\"\n[feature.test.tasks]\ntest = \"pytest --md=report.md\"\n\n[environments]\n# both default and prod will have exactly the same dependency versions when they share a dependency\ndefault = {features = [\"test\"], solve-group = \"prod-group\"}\nprod = {features = [], solve-group = \"prod-group\"}\n</code></pre> In ci you would run the following commands: <pre><code>pixi run postinstall-e &amp;&amp; pixi run test\n</code></pre> Locally you would run the following command: <pre><code>pixi run postinstall-e &amp;&amp; pixi run dev\n</code></pre></p> <p>Then in a Dockerfile you would run the following command: Dockerfile<pre><code>FROM ghcr.io/prefix-dev/pixi:latest # this doesn't exist yet\nWORKDIR /app\nCOPY . .\nRUN pixi run --environment prod postinstall\nEXPOSE 8080\nCMD [\"/usr/local/bin/pixi\", \"run\", \"--environment\", \"prod\", \"serve\"]\n</code></pre></p> Multiple machines from one project <p>This is an example for an ML project that should be executable on a machine that supports <code>cuda</code> and <code>mlx</code>. It should also be executable on machines that don't support <code>cuda</code> or <code>mlx</code>, we use the <code>cpu</code> feature for this.</p> pixi.toml<pre><code>[project]\nname = \"my-ml-project\"\ndescription = \"A project that does ML stuff\"\nauthors = [\"Your Name &lt;your.name@gmail.com&gt;\"]\nchannels = [\"conda-forge\", \"pytorch\"]\n# All platforms that are supported by the project as the features will take the intersection of the platforms defined there.\nplatforms = [\"win-64\", \"linux-64\", \"osx-64\", \"osx-arm64\"]\n\n[tasks]\ntrain-model = \"python train.py\"\nevaluate-model = \"python test.py\"\n\n[dependencies]\npython = \"3.11.*\"\npytorch = {version = \"&gt;=2.0.1\", channel = \"pytorch\"}\ntorchvision = {version = \"&gt;=0.15\", channel = \"pytorch\"}\npolars = \"&gt;=0.20,&lt;0.21\"\nmatplotlib-base = \"&gt;=3.8.2,&lt;3.9\"\nipykernel = \"&gt;=6.28.0,&lt;6.29\"\n\n[feature.cuda]\nplatforms = [\"win-64\", \"linux-64\"]\nchannels = [\"nvidia\", {channel = \"pytorch\", priority = -1}]\nsystem-requirements = {cuda = \"12.1\"}\n\n[feature.cuda.tasks]\ntrain-model = \"python train.py --cuda\"\nevaluate-model = \"python test.py --cuda\"\n\n[feature.cuda.dependencies]\npytorch-cuda = {version = \"12.1.*\", channel = \"pytorch\"}\n\n[feature.mlx]\nplatforms = [\"osx-arm64\"]\n\n[feature.mlx.tasks]\ntrain-model = \"python train.py --mlx\"\nevaluate-model = \"python test.py --mlx\"\n\n[feature.mlx.dependencies]\nmlx = \"&gt;=0.5.0,&lt;0.6.0\"\n\n[feature.cpu]\nplatforms = [\"win-64\", \"linux-64\", \"osx-64\", \"osx-arm64\"]\n\n[environments]\ncuda = [\"cuda\"]\nmlx = [\"mlx\"]\ndefault = [\"cpu\"]\n</code></pre> Running the project on a cuda machine<pre><code>pixi run train-model --environment cuda\n# will execute `python train.py --cuda`\n# fails if not on linux-64 or win-64 with cuda 12.1\n</code></pre> Running the project with mlx<pre><code>pixi run train-model --environment mlx\n# will execute `python train.py --mlx`\n# fails if not on osx-arm64\n</code></pre> Running the project on a machine without cuda or mlx<pre><code>pixi run train-model\n</code></pre>"},{"location":"features/multi_platform_configuration/","title":"Multi platform config","text":"<p>Pixi's vision includes being supported on all major platforms. Sometimes that needs some extra configuration to work well. On this page, you will learn what you can configure to align better with the platform you are making your application for.</p> <p>Here is an example manifest file that highlights some of the features:</p> <code>pixi.toml</code><code>pyproject.toml</code> pixi.toml<pre><code>[project]\n# Default project info....\n# A list of platforms you are supporting with your package.\nplatforms = [\"win-64\", \"linux-64\", \"osx-64\", \"osx-arm64\"]\n\n[dependencies]\npython = \"&gt;=3.8\"\n\n[target.win-64.dependencies]\n# Overwrite the needed python version only on win-64\npython = \"3.7\"\n\n\n[activation]\nscripts = [\"setup.sh\"]\n\n[target.win-64.activation]\n# Overwrite activation scripts only for windows\nscripts = [\"setup.bat\"]\n</code></pre> pyproject.toml<pre><code>[tool.pixi.project]\n# Default project info....\n# A list of platforms you are supporting with your package.\nplatforms = [\"win-64\", \"linux-64\", \"osx-64\", \"osx-arm64\"]\n\n[tool.pixi.dependencies]\npython = \"&gt;=3.8\"\n\n[tool.pixi.target.win-64.dependencies]\n# Overwrite the needed python version only on win-64\npython = \"~=3.7.0\"\n\n\n[tool.pixi.activation]\nscripts = [\"setup.sh\"]\n\n[tool.pixi.target.win-64.activation]\n# Overwrite activation scripts only for windows\nscripts = [\"setup.bat\"]\n</code></pre>"},{"location":"features/multi_platform_configuration/#platform-definition","title":"Platform definition","text":"<p>The <code>project.platforms</code> defines which platforms your project supports. When multiple platforms are defined, pixi determines which dependencies to install for each platform individually. All of this is stored in a lock file.</p> <p>Running <code>pixi install</code> on a platform that is not configured will warn the user that it is not setup for that platform:</p> <pre><code>\u276f pixi install\n  \u00d7 the project is not configured for your current platform\n   \u256d\u2500[pixi.toml:6:1]\n 6 \u2502 channels = [\"conda-forge\"]\n 7 \u2502 platforms = [\"osx-64\", \"osx-arm64\", \"win-64\"]\n   \u00b7             \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   \u00b7                             \u2570\u2500\u2500 add 'linux-64' here\n 8 \u2502\n   \u2570\u2500\u2500\u2500\u2500\n  help: The project needs to be configured to support your platform (linux-64).\n</code></pre>"},{"location":"features/multi_platform_configuration/#target-specifier","title":"Target specifier","text":"<p>With the target specifier, you can overwrite the original configuration specifically for a single platform. If you are targeting a specific platform in your target specifier that was not specified in your <code>project.platforms</code> then pixi will throw an error.</p>"},{"location":"features/multi_platform_configuration/#dependencies","title":"Dependencies","text":"<p>It might happen that you want to install a certain dependency only on a specific platform, or you might want to use a different version on different platforms.</p> pixi.toml<pre><code>[dependencies]\npython = \"&gt;=3.8\"\n\n[target.win-64.dependencies]\nmsmpi = \"*\"\npython = \"3.8\"\n</code></pre> <p>In the above example, we specify that we depend on <code>msmpi</code> only on Windows. We also specifically want <code>python</code> on <code>3.8</code> when installing on Windows. This will overwrite the dependencies from the generic set of dependencies. This will not touch any of the other platforms.</p> <p>You can use pixi's cli to add these dependencies to the manifest file.</p> <pre><code>pixi add --platform win-64 posix\n</code></pre> <p>This also works for the <code>host</code> and <code>build</code> dependencies.</p> <pre><code>pixi add --host --platform win-64 posix\npixi add --build --platform osx-64 clang\n</code></pre> <p>Which results in this.</p> pixi.toml<pre><code>[target.win-64.host-dependencies]\nposix = \"1.0.0.*\"\n\n[target.osx-64.build-dependencies]\nclang = \"16.0.6.*\"\n</code></pre>"},{"location":"features/multi_platform_configuration/#activation","title":"Activation","text":"<p>Pixi's vision is to enable completely cross-platform projects, but you often need to run tools that are not built by your projects. Generated activation scripts are often in this category, default scripts in unix are <code>bash</code> and for windows they are <code>bat</code></p> <p>To deal with this, you can define your activation scripts using the target definition.</p> <p>pixi.toml<pre><code>[activation]\nscripts = [\"setup.sh\", \"local_setup.bash\"]\n\n[target.win-64.activation]\nscripts = [\"setup.bat\", \"local_setup.bat\"]\n</code></pre> When this project is run on <code>win-64</code> it will only execute the target scripts not the scripts specified in the default <code>activation.scripts</code></p>"},{"location":"ide_integration/jupyterlab/","title":"JupyterLab Integration","text":""},{"location":"ide_integration/jupyterlab/#basic-usage","title":"Basic usage","text":"<p>Using JupyterLab with pixi is very simple. You can just create a new pixi project and add the <code>jupyterlab</code> package to it. The full example is provided under the following Github link.</p> <pre><code>pixi init\npixi add jupyterlab\n</code></pre> <p>This will create a new pixi project and add the <code>jupyterlab</code> package to it. You can then start JupyterLab using the following command:</p> <pre><code>pixi run jupyter lab\n</code></pre> <p>If you want to add more \"kernels\" to JupyterLab, you can simply add them to your current project \u2013 as well as any dependencies from the scientific stack you might need.</p> <pre><code>pixi add bash_kernel ipywidgets matplotlib numpy pandas  # ...\n</code></pre>"},{"location":"ide_integration/jupyterlab/#what-kernels-are-available","title":"What kernels are available?","text":"<p>You can easily install more \"kernels\" for JupyterLab. The <code>conda-forge</code> repository has a number of interesting additional kernels - not just Python!</p> <ul> <li><code>bash_kernel</code> A kernel for bash</li> <li><code>xeus-cpp</code> A C++ kernel based on the new clang-repl</li> <li><code>xeus-cling</code> A C++ kernel based on the slightly older Cling</li> <li><code>xeus-lua</code> A Lua kernel</li> <li><code>xeus-sql</code> A kernel for SQL</li> <li><code>r-irkernel</code> An R kernel</li> </ul>"},{"location":"ide_integration/jupyterlab/#advanced-usage","title":"Advanced usage","text":"<p>If you want to have only one instance of JupyterLab running but still want per-directory Pixi environments, you can use one of the kernels provided by the <code>pixi-kernel</code> package.</p>"},{"location":"ide_integration/jupyterlab/#configuring-jupyterlab","title":"Configuring JupyterLab","text":"<p>To get started, create a Pixi project, add <code>jupyterlab</code> and <code>pixi-kernel</code> and then start JupyterLab:</p> <pre><code>pixi init\npixi add jupyterlab pixi-kernel\npixi run jupyter lab\n</code></pre> <p>This will start JupyterLab and open it in your browser.</p> <p> </p> <p><code>pixi-kernel</code> searches for a manifest file, either <code>pixi.toml</code> or <code>pyproject.toml</code>, in the same directory of your notebook or in any parent directory. When it finds one, it will use the environment specified in the manifest file to start the kernel and run your notebooks.</p>"},{"location":"ide_integration/jupyterlab/#binder","title":"Binder","text":"<p>If you just want to check a JupyterLab environment running in the cloud using <code>pixi-kernel</code>, you can visit Binder.</p>"},{"location":"ide_integration/pycharm/","title":"PyCharm Integration","text":"<p>You can use PyCharm with pixi environments by using the <code>conda</code> shim provided by the pixi-pycharm package.</p>"},{"location":"ide_integration/pycharm/#how-to-use","title":"How to use","text":"<p>To get started, add <code>pixi-pycharm</code> to your pixi project.</p> <pre><code>pixi add pixi-pycharm\n</code></pre> <p>This will ensure that the conda shim is installed in your project's environment.</p> <p>Having <code>pixi-pycharm</code> installed, you can now configure PyCharm to use your pixi environments. Go to the Add Python Interpreter dialog (bottom right corner of the PyCharm window) and select Conda Environment. Set Conda Executable to the full path of the <code>conda</code> file (on Windows: <code>conda.bat</code>) which is located in <code>.pixi/envs/default/libexec</code>. You can get the path using the following command:</p> Linux &amp; macOSWindows <pre><code>pixi run 'echo $CONDA_PREFIX/libexec/conda'\n</code></pre> <pre><code>pixi run 'echo $CONDA_PREFIX\\\\libexec\\\\conda.bat'\n</code></pre> <p>This is an executable that tricks PyCharm into thinking it's the proper <code>conda</code> executable. Under the hood it redirects all calls to the corresponding <code>pixi</code> equivalent.</p> <p>Use the conda shim from this pixi project</p> <p>Please make sure that this is the <code>conda</code> shim from this pixi project and not another one. If you use multiple pixi projects, you might have to adjust the path accordingly as PyCharm remembers the path to the conda executable.</p> <p> </p> <p>Having selected the environment, PyCharm will now use the Python interpreter from your pixi environment.</p> <p>PyCharm should now be able to show you the installed packages as well.</p> <p> </p> <p>You can now run your programs and tests as usual.</p> <p> </p>"},{"location":"ide_integration/pycharm/#multiple-environments","title":"Multiple environments","text":"<p>If your project uses multiple environments to tests different Python versions or dependencies, you can add multiple environments to PyCharm by specifying Use existing environment in the Add Python Interpreter dialog.</p> <p> </p> <p>You can then specify the corresponding environment in the bottom right corner of the PyCharm window.</p> <p> </p>"},{"location":"ide_integration/pycharm/#multiple-pixi-projects","title":"Multiple pixi projects","text":"<p>When using multiple pixi projects, remember to select the correct Conda Executable for each project as mentioned above. It also might come up that you have multiple environments it might come up that you have multiple environments with the same name.</p> <p> </p> <p>It is recommended to rename the environments to something unique.</p>"},{"location":"ide_integration/pycharm/#debugging","title":"Debugging","text":"<p>Logs are written to <code>~/.cache/pixi-pycharm.log</code>. You can use them to debug problems. Please attach the logs when filing a bug report.</p>"},{"location":"ide_integration/r_studio/","title":"Developing R scripts in RStudio","text":"<p>You can use <code>pixi</code> to manage your R dependencies. The conda-forge channel contains a wide range of R packages that can be installed using <code>pixi</code>.</p>"},{"location":"ide_integration/r_studio/#installing-r-packages","title":"Installing R packages","text":"<p>R packages are usually prefixed with <code>r-</code> in the conda-forge channel. To install an R package, you can use the following command:</p> <pre><code>pixi add r-&lt;package-name&gt;\n# for example\npixi add r-ggplot2\n</code></pre>"},{"location":"ide_integration/r_studio/#using-r-packages-in-rstudio","title":"Using R packages in RStudio","text":"<p>To use the R packages installed by <code>pixi</code> in RStudio, you need to run <code>rstudio</code> from an activated environment. This can be achieved by running RStudio from <code>pixi shell</code> or from a task in the <code>pixi.toml</code> file.</p>"},{"location":"ide_integration/r_studio/#full-example","title":"Full example","text":"<p>The full example can be found here: RStudio example. Here is an example of a <code>pixi.toml</code> file that sets up an RStudio task:</p> <pre><code>[project]\nname = \"r\"\nchannels = [\"conda-forge\"]\nplatforms = [\"linux-64\", \"osx-64\", \"osx-arm64\"]\n\n[target.linux.tasks]\nrstudio = \"rstudio\"\n\n[target.osx.tasks]\nrstudio = \"open -a rstudio\"\n# or alternatively with the full path:\n# rstudio = \"/Applications/RStudio.app/Contents/MacOS/RStudio\"\n\n[dependencies]\nr = \"&gt;=4.3,&lt;5\"\nr-ggplot2 = \"&gt;=3.5.0,&lt;3.6\"\n</code></pre> <p>Once RStudio has loaded, you can execute the following R code that uses the <code>ggplot2</code> package:</p> <pre><code># Load the ggplot2 package\nlibrary(ggplot2)\n\n# Load the built-in 'mtcars' dataset\ndata &lt;- mtcars\n\n# Create a scatterplot of 'mpg' vs 'wt'\nggplot(data, aes(x = wt, y = mpg)) +\n  geom_point() +\n  labs(x = \"Weight (1000 lbs)\", y = \"Miles per Gallon\") +\n  ggtitle(\"Fuel Efficiency vs. Weight\")\n</code></pre> <p>Note</p> <p>This example assumes that you have installed RStudio system-wide. We are working on updating RStudio as well as the R interpreter builds on Windows for maximum compatibility with <code>pixi</code>.</p>"},{"location":"reference/cli/","title":"Commands","text":""},{"location":"reference/cli/#global-options","title":"Global options","text":"<ul> <li><code>--verbose (-v|vv|vvv)</code> Increase the verbosity of the output messages, the -v|vv|vvv increases the level of verbosity respectively.</li> <li><code>--help (-h)</code> Shows help information, use <code>-h</code> to get the short version of the help.</li> <li><code>--version (-V)</code>: shows the version of pixi that is used.</li> <li><code>--quiet (-q)</code>: Decreases the amount of output.</li> <li><code>--color &lt;COLOR&gt;</code>: Whether the log needs to be colored [env: <code>PIXI_COLOR=</code>] [default: <code>auto</code>] [possible values: <code>always</code>, <code>never</code>, <code>auto</code>].   Pixi also honors the <code>FORCE_COLOR</code> and <code>NO_COLOR</code> environment variables.   They both take precedence over <code>--color</code> and <code>PIXI_COLOR</code>.</li> <li><code>--no-progress</code>: Disables the progress bar.[env: <code>PIXI_NO_PROGRESS</code>] [default: <code>false</code>]</li> </ul>"},{"location":"reference/cli/#init","title":"<code>init</code>","text":"<p>This command is used to create a new project. It initializes a <code>pixi.toml</code> file and also prepares a <code>.gitignore</code> to prevent the environment from being added to <code>git</code>.</p> <p>It also supports the <code>pyproject.toml</code> file, if you have a <code>pyproject.toml</code> file in the directory where you run <code>pixi init</code>, it appends the pixi data to the <code>pyproject.toml</code> instead of a new <code>pixi.toml</code> file.</p>"},{"location":"reference/cli/#arguments","title":"Arguments","text":"<ol> <li><code>[PATH]</code>: Where to place the project (defaults to current path) [default: <code>.</code>]</li> </ol>"},{"location":"reference/cli/#options","title":"Options","text":"<ul> <li><code>--channel &lt;CHANNEL&gt; (-c)</code>: specify a channel that the project uses. Defaults to <code>conda-forge</code>. (Allowed to be used more than once)</li> <li><code>--platform &lt;PLATFORM&gt; (-p)</code>: specify a platform that the project supports. (Allowed to be used more than once)</li> <li><code>--import &lt;ENV_FILE&gt; (-i)</code>: Import an existing conda environment file, e.g. <code>environment.yml</code>.</li> <li><code>--pyproject</code>: Create a <code>pyproject.toml</code> manifest, rather than a <code>pixi.toml</code> manifest. Recommended for a python project.</li> </ul> <p>Importing an environment.yml</p> <p>When importing an environment, the <code>pixi.toml</code> will be created with the dependencies from the environment file.   The <code>pixi.lock</code> will be created when you install the environment.   We don't support <code>git+</code> urls as dependencies for pip packages and for the <code>defaults</code> channel we use <code>main</code>, <code>r</code> and <code>msys2</code> as the default channels.</p> <pre><code>pixi init myproject\npixi init ~/myproject\npixi init  # Initializes directly in the current directory.\npixi init --channel conda-forge --channel bioconda myproject\npixi init --platform osx-64 --platform linux-64 myproject\npixi init --import environment.yml\n</code></pre>"},{"location":"reference/cli/#add","title":"<code>add</code>","text":"<p>Adds dependencies to the manifest file. It will only add if the package with its version constraint is able to work with rest of the dependencies in the project. More info on multi-platform configuration.</p> <p>If the project manifest is a <code>pyproject.toml</code>, adding a pypi dependency will add it to the native pyproject <code>project.dependencies</code> array, or to the native <code>project.optional-dependencies</code> table if a feature is specified: - <code>pixi add --pypi boto3</code> would add <code>boto3</code> to the <code>project.dependencies</code> array - <code>pixi add --pypi boto3 --feature aws</code> would add <code>boto3</code> to the <code>project.dependencies.aws</code> array</p> <p>These dependencies will be read by pixi as if they had been added to the pixi <code>pypi-dependencies</code> tables of the default or a named feature.</p>"},{"location":"reference/cli/#arguments_1","title":"Arguments","text":"<ol> <li><code>&lt;SPECS&gt;</code>: The package(s) to add, space separated. The version constraint is optional.</li> </ol>"},{"location":"reference/cli/#options_1","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to manifest file, by default it searches for one in the parent directories.</li> <li><code>--host</code>: Specifies a host dependency, important for building a package.</li> <li><code>--build</code>: Specifies a build dependency, important for building a package.</li> <li><code>--pypi</code>: Specifies a PyPI dependency, not a conda package.   Parses dependencies as PEP508 requirements, supporting extras and versions.   See configuration for details.</li> <li><code>--no-install</code>: Don't install the package to the environment, only add the package to the lock-file.</li> <li><code>--no-lockfile-update</code>: Don't update the lock-file, implies the <code>--no-install</code> flag.</li> <li><code>--platform &lt;PLATFORM&gt; (-p)</code>: The platform for which the dependency should be added. (Allowed to be used more than once)</li> <li><code>--feature &lt;FEATURE&gt; (-f)</code>: The feature for which the dependency should be added.</li> </ul> <pre><code>pixi add numpy\npixi add numpy pandas \"pytorch&gt;=1.8\"\npixi add \"numpy&gt;=1.22,&lt;1.24\"\npixi add --manifest-path ~/myproject/pixi.toml numpy\npixi add --host \"python&gt;=3.9.0\"\npixi add --build cmake\npixi add --pypi requests[security]\npixi add --pypi \"boltons @ https://files.pythonhosted.org/packages/46/35/e50d4a115f93e2a3fbf52438435bb2efcf14c11d4fcd6bdcd77a6fc399c9/boltons-24.0.0-py3-none-any.whl\"\npixi add --pypi \"exchangelib @ git+https://github.com/ecederstrand/exchangelib\"\npixi add --pypi \"project @ file:///absolute/path/to/project\"\npixi add --platform osx-64 --build clang\npixi add --no-install numpy\npixi add --no-lockfile-update numpy\npixi add --feature featurex numpy\n</code></pre>"},{"location":"reference/cli/#install","title":"<code>install</code>","text":"<p>Installs an environment based on the manifest file. If there is no <code>pixi.lock</code> file or it is not up-to-date with the manifest file, it will (re-)generate the lock file.</p> <p><code>pixi install</code> only installs one environment at a time, if you have multiple environments you can select the right one with the <code>--environment</code> flag. If you don't provide an environment, the <code>default</code> environment will be installed.</p> <p>Running <code>pixi install</code> is not required before running other commands. As all commands interacting with the environment will first run the <code>install</code> command if the environment is not ready, to make sure you always run in a correct state. E.g. <code>pixi run</code>, <code>pixi shell</code>, <code>pixi shell-hook</code>, <code>pixi add</code>, <code>pixi remove</code> to name a few.</p>"},{"location":"reference/cli/#options_2","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to manifest file, by default it searches for one in the parent directories.</li> <li><code>--frozen</code>: install the environment as defined in the lock file, doesn't update <code>pixi.lock</code> if it isn't up-to-date with manifest file. It can also be controlled by the <code>PIXI_FROZEN</code> environment variable (example: <code>PIXI_FROZEN=true</code>).</li> <li><code>--locked</code>: only install if the <code>pixi.lock</code> is up-to-date with the manifest file<sup>1</sup>. It can also be controlled by the <code>PIXI_LOCKED</code> environment variable (example: <code>PIXI_LOCKED=true</code>). Conflicts with <code>--frozen</code>.</li> <li><code>--environment &lt;ENVIRONMENT&gt; (-e)</code>: The environment to install, if none are provided the default environment will be used.</li> </ul> <pre><code>pixi install\npixi install --manifest-path ~/myproject/pixi.toml\npixi install --frozen\npixi install --locked\npixi install --environment lint\npixi install -e lint\n</code></pre> <p>To reinitialize the lock file in your project, you can remove the existing <code>pixi.lock</code> file and run <code>pixi install</code>. This process will regenerate the lock file based on the dependencies defined in your manifest file:</p> <pre><code>rm pixi.lock &amp;&amp; pixi install\n</code></pre> <p>This action ensures that your project's dependencies are reset and updated according to the current specifications in manifest file.</p> <p>In a future version of <code>pixi</code>, we will introduce the <code>pixi update</code> command, see #73. This command will allow you to update the lock file directly, without manually deleting the <code>pixi.lock</code> file, making the dependency management process even smoother.</p>"},{"location":"reference/cli/#run","title":"<code>run</code>","text":"<p>The <code>run</code> commands first checks if the environment is ready to use. When you didn't run <code>pixi install</code> the run command will do that for you. The custom tasks defined in the manifest file are also available through the run command.</p> <p>You cannot run <code>pixi run source setup.bash</code> as <code>source</code> is not available in the <code>deno_task_shell</code> commandos and not an executable.</p>"},{"location":"reference/cli/#arguments_2","title":"Arguments","text":"<ol> <li><code>[TASK]...</code> The task you want to run in the projects environment, this can also be a normal command. And all arguments after the task will be passed to the task.</li> </ol>"},{"location":"reference/cli/#options_3","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to manifest file, by default it searches for one in the parent directories.</li> <li><code>--frozen</code>: install the environment as defined in the lock file, doesn't update <code>pixi.lock</code> if it isn't up-to-date with manifest file. It can also be controlled by the <code>PIXI_FROZEN</code> environment variable (example: <code>PIXI_FROZEN=true</code>).</li> <li><code>--locked</code>: only install if the <code>pixi.lock</code> is up-to-date with the manifest file<sup>1</sup>. It can also be controlled by the <code>PIXI_LOCKED</code> environment variable (example: <code>PIXI_LOCKED=true</code>). Conflicts with <code>--frozen</code>.</li> <li><code>--environment &lt;ENVIRONMENT&gt; (-e)</code>: The environment to run the task in, if none are provided the default environment will be used or a selector will be given to select the right environment.</li> </ul> <pre><code>pixi run python\npixi run cowpy \"Hey pixi user\"\npixi run --manifest-path ~/myproject/pixi.toml python\npixi run --frozen python\npixi run --locked python\n# If you have specified a custom task in the pixi.toml you can run it with run as well\npixi run build\n# Extra arguments will be passed to the tasks command.\npixi run task argument1 argument2\n\n# If you have multiple environments you can select the right one with the --environment flag.\npixi run --environment cuda python\n</code></pre> <p>Info</p> <p>In <code>pixi</code> the <code>deno_task_shell</code> is the underlying runner of the run command. Checkout their documentation for the syntax and available commands. This is done so that the run commands can be run across all platforms.</p> <p>Cross environment tasks</p> <p>If you're using the <code>depends-on</code> feature of the <code>tasks</code>, the tasks will be run in the order you specified them. The <code>depends-on</code> can be used cross environment, e.g. you have this <code>pixi.toml</code>:</p> pixi.toml <pre><code>[tasks]\nstart = { cmd = \"python start.py\", depends-on = [\"build\"] }\n\n[feature.build.tasks]\nbuild = \"cargo build\"\n[feature.build.dependencies]\nrust = \"&gt;=1.74\"\n\n[environments]\nbuild = [\"build\"]\n</code></pre> <p>Then you're able to run the <code>build</code> from the <code>build</code> environment and <code>start</code> from the default environment. By only calling: <pre><code>pixi run start\n</code></pre></p>"},{"location":"reference/cli/#remove","title":"<code>remove</code>","text":"<p>Removes dependencies from the manifest file.</p> <p>If the project manifest is a <code>pyproject.toml</code>, removing a pypi dependency with the <code>--pypi</code> flag will remove it from either - the native pyproject <code>project.dependencies</code> array or the native <code>project.optional-dependencies</code> table (if a feature is specified) - pixi <code>pypi-dependencies</code> tables of the default or a named feature (if a feature is specified)</p>"},{"location":"reference/cli/#arguments_3","title":"Arguments","text":"<ol> <li><code>&lt;DEPS&gt;...</code>: List of dependencies you wish to remove from the project.</li> </ol>"},{"location":"reference/cli/#options_4","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to manifest file, by default it searches for one in the parent directories.</li> <li><code>--host</code>: Specifies a host dependency, important for building a package.</li> <li><code>--build</code>: Specifies a build dependency, important for building a package.</li> <li><code>--pypi</code>: Specifies a PyPI dependency, not a conda package.</li> <li><code>--platform &lt;PLATFORM&gt; (-p)</code>: The platform from which the dependency should be removed.</li> <li><code>--feature &lt;FEATURE&gt; (-f)</code>: The feature from which the dependency should be removed.</li> <li><code>--no-install</code>: Don't install the environment, only remove the package from the lock-file and manifest.</li> </ul> <pre><code>pixi remove numpy\npixi remove numpy pandas pytorch\npixi remove --manifest-path ~/myproject/pixi.toml numpy\npixi remove --host python\npixi remove --build cmake\npixi remove --pypi requests\npixi remove --platform osx-64 --build clang\npixi remove --feature featurex clang\npixi remove --feature featurex --platform osx-64 clang\npixi remove --feature featurex --platform osx-64 --build clang\npixi remove --no-install numpy\n</code></pre>"},{"location":"reference/cli/#task","title":"<code>task</code>","text":"<p>If you want to make a shorthand for a specific command you can add a task for it.</p>"},{"location":"reference/cli/#options_5","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to manifest file, by default it searches for one in the parent directories.</li> </ul>"},{"location":"reference/cli/#task-add","title":"<code>task add</code>","text":"<p>Add a task to the manifest file, use <code>--depends-on</code> to add tasks you want to run before this task, e.g. build before an execute task.</p>"},{"location":"reference/cli/#arguments_4","title":"Arguments","text":"<ol> <li><code>&lt;NAME&gt;</code>: The name of the task.</li> <li><code>&lt;COMMAND&gt;</code>: The command to run. This can be more than one word.</li> </ol> <p>Info</p> <p>If you are using <code>$</code> for env variables they will be resolved before adding them to the task. If you want to use <code>$</code> in the task you need to escape it with a <code>\\</code>, e.g. <code>echo \\$HOME</code>.</p>"},{"location":"reference/cli/#options_6","title":"Options","text":"<ul> <li><code>--platform &lt;PLATFORM&gt; (-p)</code>: the platform for which this task should be added.</li> <li><code>--feature &lt;FEATURE&gt; (-f)</code>: the feature for which the task is added, if non provided the default tasks will be added.</li> <li><code>--depends-on &lt;DEPENDS_ON&gt;</code>: the task it depends on to be run before the one your adding.</li> <li><code>--cwd &lt;CWD&gt;</code>: the working directory for the task relative to the root of the project.</li> </ul> <pre><code>pixi task add cow cowpy \"Hello User\"\npixi task add tls ls --cwd tests\npixi task add test cargo t --depends-on build\npixi task add build-osx \"METAL=1 cargo build\" --platform osx-64\npixi task add train python train.py --feature cuda\n</code></pre> <p>This adds the following to the manifest file:</p> <pre><code>[tasks]\ncow = \"cowpy \\\"Hello User\\\"\"\ntls = { cmd = \"ls\", cwd = \"tests\" }\ntest = { cmd = \"cargo t\", depends-on = [\"build\"] }\n\n[target.osx-64.tasks]\nbuild-osx = \"METAL=1 cargo build\"\n\n[feature.cuda.tasks]\ntrain = \"python train.py\"\n</code></pre> <p>Which you can then run with the <code>run</code> command:</p> <pre><code>pixi run cow\n# Extra arguments will be passed to the tasks command.\npixi run test --test test1\n</code></pre>"},{"location":"reference/cli/#task-remove","title":"<code>task remove</code>","text":"<p>Remove the task from the manifest file</p>"},{"location":"reference/cli/#arguments_5","title":"Arguments","text":"<ul> <li><code>&lt;NAMES&gt;</code>: The names of the tasks, space separated.</li> </ul>"},{"location":"reference/cli/#options_7","title":"Options","text":"<ul> <li><code>--platform &lt;PLATFORM&gt; (-p)</code>: the platform for which this task is removed.</li> <li><code>--feature &lt;FEATURE&gt; (-f)</code>: the feature for which the task is removed.</li> </ul> <pre><code>pixi task remove cow\npixi task remove --platform linux-64 test\npixi task remove --feature cuda task\n</code></pre>"},{"location":"reference/cli/#task-alias","title":"<code>task alias</code>","text":"<p>Create an alias for a task.</p>"},{"location":"reference/cli/#arguments_6","title":"Arguments","text":"<ol> <li><code>&lt;ALIAS&gt;</code>: The alias name</li> <li><code>&lt;DEPENDS_ON&gt;</code>: The names of the tasks you want to execute on this alias, order counts, first one runs first.</li> </ol>"},{"location":"reference/cli/#options_8","title":"Options","text":"<ul> <li><code>--platform &lt;PLATFORM&gt; (-p)</code>: the platform for which this alias is created.</li> </ul> <pre><code>pixi task alias test-all test-py test-cpp test-rust\npixi task alias --platform linux-64 test test-linux\npixi task alias moo cow\n</code></pre>"},{"location":"reference/cli/#task-list","title":"<code>task list</code>","text":"<p>List all tasks in the project.</p>"},{"location":"reference/cli/#options_9","title":"Options","text":"<ul> <li><code>--environment</code>(<code>-e</code>): the environment's tasks list, if non is provided the default tasks will be listed.</li> <li><code>--summary</code>(<code>-s</code>): the output gets formatted to be machine parsable. (Used in the autocompletion of <code>pixi run</code>).</li> </ul> <pre><code>pixi task list\npixi task list --environment cuda\npixi task list --summary\n</code></pre>"},{"location":"reference/cli/#list","title":"<code>list</code>","text":"<p>List project's packages. Highlighted packages are explicit dependencies.</p>"},{"location":"reference/cli/#options_10","title":"Options","text":"<ul> <li><code>--platform &lt;PLATFORM&gt; (-p)</code>: The platform to list packages for. Defaults to the current platform</li> <li><code>--json</code>: Whether to output in json format.</li> <li><code>--json-pretty</code>: Whether to output in pretty json format</li> <li><code>--sort-by &lt;SORT_BY&gt;</code>: Sorting strategy [default: name] [possible values: size, name, type]</li> <li><code>--explicit (-x)</code>: Only list the packages that are explicitly added to the manifest file.</li> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: The path to manifest file, by default it searches for one in the parent directories.</li> <li><code>--environment (-e)</code>: The environment's packages to list, if non is provided the default environment's packages will be listed.</li> <li><code>--frozen</code>: install the environment as defined in the lock file, doesn't update <code>pixi.lock</code> if it isn't up-to-date with manifest file. It can also be controlled by the <code>PIXI_FROZEN</code> environment variable (example: <code>PIXI_FROZEN=true</code>).</li> <li><code>--locked</code>: Only install if the <code>pixi.lock</code> is up-to-date with the manifest file<sup>1</sup>. It can also be controlled by the <code>PIXI_LOCKED</code> environment variable (example: <code>PIXI_LOCKED=true</code>). Conflicts with <code>--frozen</code>.</li> <li><code>--no-install</code>: Don't install the environment for pypi solving, only update the lock-file if it can solve without installing. (Implied by <code>--frozen</code> and <code>--locked</code>)</li> </ul> <pre><code>pixi list\npixi list --json-pretty\npixi list --explicit\npixi list --sort-by size\npixi list --platform win-64\npixi list --environment cuda\npixi list --frozen\npixi list --locked\npixi list --no-install\n</code></pre> <p>Output will look like this, where <code>python</code> will be green as it is the package that was explicitly added to the manifest file:</p> <pre><code>\u279c pixi list\n Package           Version     Build               Size       Kind   Source\n _libgcc_mutex     0.1         conda_forge         2.5 KiB    conda  _libgcc_mutex-0.1-conda_forge.tar.bz2\n _openmp_mutex     4.5         2_gnu               23.1 KiB   conda  _openmp_mutex-4.5-2_gnu.tar.bz2\n bzip2             1.0.8       hd590300_5          248.3 KiB  conda  bzip2-1.0.8-hd590300_5.conda\n ca-certificates   2023.11.17  hbcca054_0          150.5 KiB  conda  ca-certificates-2023.11.17-hbcca054_0.conda\n ld_impl_linux-64  2.40        h41732ed_0          688.2 KiB  conda  ld_impl_linux-64-2.40-h41732ed_0.conda\n libexpat          2.5.0       hcb278e6_1          76.2 KiB   conda  libexpat-2.5.0-hcb278e6_1.conda\n libffi            3.4.2       h7f98852_5          56.9 KiB   conda  libffi-3.4.2-h7f98852_5.tar.bz2\n libgcc-ng         13.2.0      h807b86a_4          755.7 KiB  conda  libgcc-ng-13.2.0-h807b86a_4.conda\n libgomp           13.2.0      h807b86a_4          412.2 KiB  conda  libgomp-13.2.0-h807b86a_4.conda\n libnsl            2.0.1       hd590300_0          32.6 KiB   conda  libnsl-2.0.1-hd590300_0.conda\n libsqlite         3.44.2      h2797004_0          826 KiB    conda  libsqlite-3.44.2-h2797004_0.conda\n libuuid           2.38.1      h0b41bf4_0          32.8 KiB   conda  libuuid-2.38.1-h0b41bf4_0.conda\n libxcrypt         4.4.36      hd590300_1          98 KiB     conda  libxcrypt-4.4.36-hd590300_1.conda\n libzlib           1.2.13      hd590300_5          60.1 KiB   conda  libzlib-1.2.13-hd590300_5.conda\n ncurses           6.4         h59595ed_2          863.7 KiB  conda  ncurses-6.4-h59595ed_2.conda\n openssl           3.2.0       hd590300_1          2.7 MiB    conda  openssl-3.2.0-hd590300_1.conda\n python            3.12.1      hab00c5b_1_cpython  30.8 MiB   conda  python-3.12.1-hab00c5b_1_cpython.conda\n readline          8.2         h8228510_1          274.9 KiB  conda  readline-8.2-h8228510_1.conda\n tk                8.6.13      noxft_h4845f30_101  3.2 MiB    conda  tk-8.6.13-noxft_h4845f30_101.conda\n tzdata            2023d       h0c530f3_0          116.8 KiB  conda  tzdata-2023d-h0c530f3_0.conda\n xz                5.2.6       h166bdaf_0          408.6 KiB  conda  xz-5.2.6-h166bdaf_0.tar.bz2\n</code></pre>"},{"location":"reference/cli/#tree","title":"<code>tree</code>","text":"<p>Display the project's packages in a tree. Highlighted packages are those specified in the manifest.</p> <p>The package tree can also be inverted (<code>-i</code>), to see which packages require a specific dependencies.</p>"},{"location":"reference/cli/#arguments_7","title":"Arguments","text":"<ul> <li><code>REGEX</code> optional regex of which dependencies to filter the tree to, or which dependencies to start with when inverting the tree.</li> </ul>"},{"location":"reference/cli/#options_11","title":"Options","text":"<ul> <li><code>--invert (-i)</code>: Invert the dependency tree, that is given a <code>REGEX</code> pattern that matches some packages, show all the packages that depend on those.</li> <li><code>--platform &lt;PLATFORM&gt; (-p)</code>: The platform to list packages for. Defaults to the current platform</li> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: The path to manifest file, by default it searches for one in the parent directories.</li> <li><code>--environment (-e)</code>: The environment's packages to list, if non is provided the default environment's packages will be listed.</li> <li><code>--frozen</code>: install the environment as defined in the lock file, doesn't update <code>pixi.lock</code> if it isn't up-to-date with manifest file. It can also be controlled by the <code>PIXI_FROZEN</code> environment variable (example: <code>PIXI_FROZEN=true</code>).</li> <li><code>--locked</code>: Only install if the <code>pixi.lock</code> is up-to-date with the manifest file<sup>1</sup>. It can also be controlled by the <code>PIXI_LOCKED</code> environment variable (example: <code>PIXI_LOCKED=true</code>). Conflicts with <code>--frozen</code>.</li> <li><code>--no-install</code>: Don't install the environment for pypi solving, only update the lock-file if it can solve without installing. (Implied by <code>--frozen</code> and <code>--locked</code>)</li> </ul> <pre><code>pixi tree\npixi tree pre-commit\npixi tree -i yaml\npixi tree --environment docs\npixi tree --platform win-64\n</code></pre> <p>Warning</p> <p>Use <code>-v</code> to show which <code>pypi</code> packages are not yet parsed correctly. The <code>extras</code> and <code>markers</code> parsing is still under development.</p> <p>Output will look like this, where direct packages in the manifest file will be green. Once a package has been displayed once, the tree won't continue to recurse through its dependencies (compare the first time <code>python</code> appears, vs the rest), and it will instead be marked with a star <code>(*)</code>.</p> <p>Version numbers are colored by the package type, yellow for Conda packages and blue for PyPI.</p> <pre><code>\u279c pixi tree\n\u251c\u2500\u2500 pre-commit v3.3.3\n\u2502   \u251c\u2500\u2500 cfgv v3.3.1\n\u2502   \u2502   \u2514\u2500\u2500 python v3.12.2\n\u2502   \u2502       \u251c\u2500\u2500 bzip2 v1.0.8\n\u2502   \u2502       \u251c\u2500\u2500 libexpat v2.6.2\n\u2502   \u2502       \u251c\u2500\u2500 libffi v3.4.2\n\u2502   \u2502       \u251c\u2500\u2500 libsqlite v3.45.2\n\u2502   \u2502       \u2502   \u2514\u2500\u2500 libzlib v1.2.13\n\u2502   \u2502       \u251c\u2500\u2500 libzlib v1.2.13 (*)\n\u2502   \u2502       \u251c\u2500\u2500 ncurses v6.4.20240210\n\u2502   \u2502       \u251c\u2500\u2500 openssl v3.2.1\n\u2502   \u2502       \u251c\u2500\u2500 readline v8.2\n\u2502   \u2502       \u2502   \u2514\u2500\u2500 ncurses v6.4.20240210 (*)\n\u2502   \u2502       \u251c\u2500\u2500 tk v8.6.13\n\u2502   \u2502       \u2502   \u2514\u2500\u2500 libzlib v1.2.13 (*)\n\u2502   \u2502       \u2514\u2500\u2500 xz v5.2.6\n\u2502   \u251c\u2500\u2500 identify v2.5.35\n\u2502   \u2502   \u2514\u2500\u2500 python v3.12.2 (*)\n...\n\u2514\u2500\u2500 tbump v6.9.0\n...\n    \u2514\u2500\u2500 tomlkit v0.12.4\n        \u2514\u2500\u2500 python v3.12.2 (*)\n</code></pre> <p>A regex pattern can be specified to filter the tree to just those that show a specific direct, or transitive dependency:</p> <pre><code>\u279c pixi tree pre-commit\n\u2514\u2500\u2500 pre-commit v3.3.3\n    \u251c\u2500\u2500 virtualenv v20.25.1\n    \u2502   \u251c\u2500\u2500 filelock v3.13.1\n    \u2502   \u2502   \u2514\u2500\u2500 python v3.12.2\n    \u2502   \u2502       \u251c\u2500\u2500 libexpat v2.6.2\n    \u2502   \u2502       \u251c\u2500\u2500 readline v8.2\n    \u2502   \u2502       \u2502   \u2514\u2500\u2500 ncurses v6.4.20240210\n    \u2502   \u2502       \u251c\u2500\u2500 libsqlite v3.45.2\n    \u2502   \u2502       \u2502   \u2514\u2500\u2500 libzlib v1.2.13\n    \u2502   \u2502       \u251c\u2500\u2500 bzip2 v1.0.8\n    \u2502   \u2502       \u251c\u2500\u2500 libzlib v1.2.13 (*)\n    \u2502   \u2502       \u251c\u2500\u2500 libffi v3.4.2\n    \u2502   \u2502       \u251c\u2500\u2500 tk v8.6.13\n    \u2502   \u2502       \u2502   \u2514\u2500\u2500 libzlib v1.2.13 (*)\n    \u2502   \u2502       \u251c\u2500\u2500 xz v5.2.6\n    \u2502   \u2502       \u251c\u2500\u2500 ncurses v6.4.20240210 (*)\n    \u2502   \u2502       \u2514\u2500\u2500 openssl v3.2.1\n    \u2502   \u251c\u2500\u2500 platformdirs v4.2.0\n    \u2502   \u2502   \u2514\u2500\u2500 python v3.12.2 (*)\n    \u2502   \u251c\u2500\u2500 distlib v0.3.8\n    \u2502   \u2502   \u2514\u2500\u2500 python v3.12.2 (*)\n    \u2502   \u2514\u2500\u2500 python v3.12.2 (*)\n    \u251c\u2500\u2500 pyyaml v6.0.1\n...\n</code></pre> <p>Additionally, the tree can be inverted, and it can show which packages depend on a regex pattern. The packages specified in the manifest will also be highlighted (in this case <code>cffconvert</code> and <code>pre-commit</code> would be).</p> <pre><code>\u279c pixi tree -i yaml\n\nruamel.yaml v0.18.6\n\u251c\u2500\u2500 pykwalify v1.8.0\n\u2502   \u2514\u2500\u2500 cffconvert v2.0.0\n\u2514\u2500\u2500 cffconvert v2.0.0\n\npyyaml v6.0.1\n\u2514\u2500\u2500 pre-commit v3.3.3\n\nruamel.yaml.clib v0.2.8\n\u2514\u2500\u2500 ruamel.yaml v0.18.6\n    \u251c\u2500\u2500 pykwalify v1.8.0\n    \u2502   \u2514\u2500\u2500 cffconvert v2.0.0\n    \u2514\u2500\u2500 cffconvert v2.0.0\n\nyaml v0.2.5\n\u2514\u2500\u2500 pyyaml v6.0.1\n    \u2514\u2500\u2500 pre-commit v3.3.3\n</code></pre>"},{"location":"reference/cli/#shell","title":"<code>shell</code>","text":"<p>This command starts a new shell in the project's environment. To exit the pixi shell, simply run <code>exit</code>.</p>"},{"location":"reference/cli/#options_12","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to manifest file, by default it searches for one in the parent directories.</li> <li><code>--frozen</code>: install the environment as defined in the lock file, doesn't update <code>pixi.lock</code> if it isn't up-to-date with manifest file. It can also be controlled by the <code>PIXI_FROZEN</code> environment variable (example: <code>PIXI_FROZEN=true</code>).</li> <li><code>--locked</code>: only install if the <code>pixi.lock</code> is up-to-date with the manifest file<sup>1</sup>. It can also be controlled by the <code>PIXI_LOCKED</code> environment variable (example: <code>PIXI_LOCKED=true</code>). Conflicts with <code>--frozen</code>.</li> <li><code>--environment &lt;ENVIRONMENT&gt; (-e)</code>: The environment to activate the shell in, if none are provided the default environment will be used or a selector will be given to select the right environment.</li> </ul> <pre><code>pixi shell\nexit\npixi shell --manifest-path ~/myproject/pixi.toml\nexit\npixi shell --frozen\nexit\npixi shell --locked\nexit\npixi shell --environment cuda\nexit\n</code></pre>"},{"location":"reference/cli/#shell-hook","title":"<code>shell-hook</code>","text":"<p>This command prints the activation script of an environment.</p>"},{"location":"reference/cli/#options_13","title":"Options","text":"<ul> <li><code>--shell &lt;SHELL&gt; (-s)</code>: The shell for which the activation script should be printed. Defaults to the current shell.   Currently supported variants: [<code>bash</code>, <code>zsh</code>, <code>xonsh</code>, <code>cmd</code>, <code>powershell</code>, <code>fish</code>, <code>nushell</code>]</li> <li><code>--manifest-path</code>: the path to manifest file, by default it searches for one in the parent directories.</li> <li><code>--frozen</code>: install the environment as defined in the lock file, doesn't update <code>pixi.lock</code> if it isn't up-to-date with manifest file. It can also be controlled by the <code>PIXI_FROZEN</code> environment variable (example: <code>PIXI_FROZEN=true</code>).</li> <li><code>--locked</code>: only install if the <code>pixi.lock</code> is up-to-date with the manifest file<sup>1</sup>. It can also be controlled by the <code>PIXI_LOCKED</code> environment variable (example: <code>PIXI_LOCKED=true</code>). Conflicts with <code>--frozen</code>.</li> <li><code>--environment &lt;ENVIRONMENT&gt; (-e)</code>: The environment to activate, if none are provided the default environment will be used or a selector will be given to select the right environment.</li> <li><code>--json</code>: Print all environment variables that are exported by running the activation script as JSON. When specifying   this option, <code>--shell</code> is ignored.</li> </ul> <pre><code>pixi shell-hook\npixi shell-hook --shell bash\npixi shell-hook --shell zsh\npixi shell-hook -s powershell\npixi shell-hook --manifest-path ~/myproject/pixi.toml\npixi shell-hook --frozen\npixi shell-hook --locked\npixi shell-hook --environment cuda\npixi shell-hook --json\n</code></pre> <p>Example use-case, when you want to get rid of the <code>pixi</code> executable in a Docker container.</p> <pre><code>pixi shell-hook --shell bash &gt; /etc/profile.d/pixi.sh\nrm ~/.pixi/bin/pixi # Now the environment will be activated without the need for the pixi executable.\n</code></pre>"},{"location":"reference/cli/#search","title":"<code>search</code>","text":"<p>Search a package, output will list the latest version of the package.</p>"},{"location":"reference/cli/#arguments_8","title":"Arguments","text":"<ol> <li><code>&lt;PACKAGE&gt;</code>: Name of package to search, it's possible to use wildcards (<code>*</code>).</li> </ol>"},{"location":"reference/cli/#options_14","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to manifest file, by default it searches for one in the parent directories.</li> <li><code>--channel &lt;CHANNEL&gt; (-c)</code>: specify a channel that the project uses. Defaults to <code>conda-forge</code>. (Allowed to be used more than once)</li> <li><code>--limit &lt;LIMIT&gt; (-l)</code>: optionally limit the number of search results</li> <li><code>--platform &lt;PLATFORM&gt; (-p)</code>: specify a platform that you want to search for. (default: current platform)</li> </ul> <pre><code>pixi search pixi\npixi search --limit 30 \"py*\"\n# search in a different channel and for a specific platform\npixi search -c robostack --platform linux-64 \"plotjuggler*\"\n</code></pre>"},{"location":"reference/cli/#self-update","title":"<code>self-update</code>","text":"<p>Update pixi to the latest version or a specific version. If the pixi binary is not found in the default location (e.g. <code>~/.pixi/bin/pixi</code>), pixi won't update to prevent breaking the current installation (Homebrew, etc.). The behaviour can be overridden with the <code>--force</code> flag</p>"},{"location":"reference/cli/#options_15","title":"Options","text":"<ul> <li><code>--version &lt;VERSION&gt;</code>: The desired version (to downgrade or upgrade to). Update to the latest version if not specified.</li> <li><code>--force</code>: Force the update even if the pixi binary is not found in the default location.</li> </ul> <pre><code>pixi self-update\npixi self-update --version 0.13.0\npixi self-update --force\n</code></pre>"},{"location":"reference/cli/#info","title":"<code>info</code>","text":"<p>Shows helpful information about the pixi installation, cache directories, disk usage, and more. More information here.</p>"},{"location":"reference/cli/#options_16","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to manifest file, by default it searches for one in the parent directories.</li> <li><code>--extended</code>: extend the information with more slow queries to the system, like directory sizes.</li> <li><code>--json</code>: Get a machine-readable version of the information as output.</li> </ul> <pre><code>pixi info\npixi info --json --extended\n</code></pre>"},{"location":"reference/cli/#upload","title":"<code>upload</code>","text":"<p>Upload a package to a prefix.dev channel</p>"},{"location":"reference/cli/#arguments_9","title":"Arguments","text":"<ol> <li><code>&lt;HOST&gt;</code>: The host + channel to upload to.</li> <li><code>&lt;PACKAGE_FILE&gt;</code>: The package file to upload.</li> </ol> <pre><code>pixi upload repo.prefix.dev/my_channel my_package.conda\n</code></pre>"},{"location":"reference/cli/#auth","title":"<code>auth</code>","text":"<p>This command is used to authenticate the user's access to remote hosts such as <code>prefix.dev</code> or <code>anaconda.org</code> for private channels.</p>"},{"location":"reference/cli/#auth-login","title":"<code>auth login</code>","text":"<p>Store authentication information for given host.</p> <p>Tip</p> <p>The host is real hostname not a channel.</p>"},{"location":"reference/cli/#arguments_10","title":"Arguments","text":"<ol> <li><code>&lt;HOST&gt;</code>: The host to authenticate with.</li> </ol>"},{"location":"reference/cli/#options_17","title":"Options","text":"<ul> <li><code>--token &lt;TOKEN&gt;</code>: The token to use for authentication with prefix.dev.</li> <li><code>--username &lt;USERNAME&gt;</code>: The username to use for basic HTTP authentication</li> <li><code>--password &lt;PASSWORD&gt;</code>: The password to use for basic HTTP authentication.</li> <li><code>--conda-token &lt;CONDA_TOKEN&gt;</code>: The token to use on <code>anaconda.org</code> / <code>quetz</code> authentication.</li> </ul> <pre><code>pixi auth login repo.prefix.dev --token pfx_JQEV-m_2bdz-D8NSyRSaNdHANx0qHjq7f2iD\npixi auth login anaconda.org --conda-token ABCDEFGHIJKLMNOP\npixi auth login https://myquetz.server --username john --password xxxxxx\n</code></pre>"},{"location":"reference/cli/#auth-logout","title":"<code>auth logout</code>","text":"<p>Remove authentication information for a given host.</p>"},{"location":"reference/cli/#arguments_11","title":"Arguments","text":"<ol> <li><code>&lt;HOST&gt;</code>: The host to authenticate with.</li> </ol> <pre><code>pixi auth logout &lt;HOST&gt;\npixi auth logout repo.prefix.dev\npixi auth logout anaconda.org\n</code></pre>"},{"location":"reference/cli/#config","title":"<code>config</code>","text":"<p>Use this command to manage the configuration.</p>"},{"location":"reference/cli/#options_18","title":"Options","text":"<ul> <li><code>--system</code>: Specify management scope to system configuration.</li> <li><code>--global</code>: Specify management scope to global configuration.</li> <li><code>--local</code>: Specify management scope to local configuration.</li> </ul> <p>Checkout the global configuration for more information about the locations.</p>"},{"location":"reference/cli/#config-edit","title":"<code>config edit</code>","text":"<p>Edit the configuration file in the default editor.</p>"},{"location":"reference/cli/#config-list","title":"<code>config list</code>","text":"<p>List the configuration</p>"},{"location":"reference/cli/#arguments_12","title":"Arguments","text":"<ol> <li><code>[KEY]</code>: The key to list the value of. (all if not provided)</li> </ol>"},{"location":"reference/cli/#options_19","title":"Options","text":"<ul> <li><code>--json</code>: Output the configuration in JSON format.</li> </ul> <pre><code>pixi config list default-channels\npixi config list --json\n</code></pre>"},{"location":"reference/cli/#config-prepend","title":"<code>config prepend</code>","text":"<p>Prepend a value to a list configuration key.</p>"},{"location":"reference/cli/#arguments_13","title":"Arguments","text":"<ol> <li><code>&lt;KEY&gt;</code>: The key to prepend the value to.</li> <li><code>&lt;VALUE&gt;</code>: The value to prepend.</li> </ol> <pre><code>pixi config prepend default-channels conda-forge\n</code></pre>"},{"location":"reference/cli/#config-append","title":"<code>config append</code>","text":"<p>Append a value to a list configuration key.</p>"},{"location":"reference/cli/#arguments_14","title":"Arguments","text":"<ol> <li><code>&lt;KEY&gt;</code>: The key to append the value to.</li> <li><code>&lt;VALUE&gt;</code>: The value to append.</li> </ol> <pre><code>pixi config append default-channels robostack\npixi config append default-channels bioconda --global\n</code></pre>"},{"location":"reference/cli/#config-set","title":"<code>config set</code>","text":"<p>Set a configuration key to a value.</p>"},{"location":"reference/cli/#arguments_15","title":"Arguments","text":"<ol> <li><code>&lt;KEY&gt;</code>: The key to set the value of.</li> <li><code>[VALUE]</code>: The value to set. (if not provided, the key will be removed)</li> </ol> <pre><code>pixi config set default-channels '[\"conda-forge\", \"bioconda\"]'\npixi config set --global mirrors '{\"https://conda.anaconda.org/\": [\"https://prefix.dev/conda-forge\"]}'\npixi config set repodata-config.disable-zstd true --system\n</code></pre>"},{"location":"reference/cli/#config-unset","title":"<code>config unset</code>","text":"<p>Unset a configuration key.</p>"},{"location":"reference/cli/#arguments_16","title":"Arguments","text":"<ol> <li><code>&lt;KEY&gt;</code>: The key to unset.</li> </ol> <pre><code>pixi config unset default-channels\npixi config unset --global mirrors\npixi config unset repodata-config.disable-zstd --system\n</code></pre>"},{"location":"reference/cli/#global","title":"<code>global</code>","text":"<p>Global is the main entry point for the part of pixi that executes on the global(system) level.</p> <p>Tip</p> <p>Binaries and environments installed globally are stored in <code>~/.pixi</code> by default, this can be changed by setting the <code>PIXI_HOME</code> environment variable.</p>"},{"location":"reference/cli/#global-install","title":"<code>global install</code>","text":"<p>This command installs package(s) into its own environment and adds the binary to <code>PATH</code>, allowing you to access it anywhere on your system without activating the environment.</p>"},{"location":"reference/cli/#arguments_17","title":"Arguments","text":"<p>1.<code>&lt;PACKAGE&gt;</code>: The package(s) to install, this can also be a version constraint.</p>"},{"location":"reference/cli/#options_20","title":"Options","text":"<ul> <li><code>--channel &lt;CHANNEL&gt; (-c)</code>: specify a channel that the project uses. Defaults to <code>conda-forge</code>. (Allowed to be used more than once)</li> </ul> <pre><code>pixi global install ruff\n# multiple packages can be installed at once\npixi global install starship rattler-build\n# specify the channel(s)\npixi global install --channel conda-forge --channel bioconda trackplot\n# Or in a more concise form\npixi global install -c conda-forge -c bioconda trackplot\n\n# Support full conda matchspec\npixi global install python=3.9.*\npixi global install \"python [version='3.11.0', build_number=1]\"\npixi global install \"python [version='3.11.0', build=he550d4f_1_cpython]\"\npixi global install python=3.11.0=h10a6764_1_cpython\n</code></pre> <p>After using global install, you can use the package you installed anywhere on your system.</p>"},{"location":"reference/cli/#global-list","title":"<code>global list</code>","text":"<p>This command shows the current installed global environments including what binaries come with it. A global installed package/environment can possibly contain multiple binaries and they will be listed out in the command output. Here is an example of a few installed packages:</p> <pre><code>&gt; pixi global list\nGlobal install location: /home/hanabi/.pixi\n\u251c\u2500\u2500 bat 0.24.0\n|   \u2514\u2500 exec: bat\n\u251c\u2500\u2500 conda-smithy 3.31.1\n|   \u2514\u2500 exec: feedstocks, conda-smithy\n\u251c\u2500\u2500 rattler-build 0.13.0\n|   \u2514\u2500 exec: rattler-build\n\u251c\u2500\u2500 ripgrep 14.1.0\n|   \u2514\u2500 exec: rg\n\u2514\u2500\u2500 uv 0.1.17\n    \u2514\u2500 exec: uv\n</code></pre>"},{"location":"reference/cli/#global-upgrade","title":"<code>global upgrade</code>","text":"<p>This command upgrades a globally installed package (to the latest version by default).</p>"},{"location":"reference/cli/#arguments_18","title":"Arguments","text":"<ol> <li><code>&lt;PACKAGE&gt;</code>: The package to upgrade.</li> </ol>"},{"location":"reference/cli/#options_21","title":"Options","text":"<ul> <li><code>--channel &lt;CHANNEL&gt; (-c)</code>: specify a channel that the project uses.   Defaults to <code>conda-forge</code>. Note the channel the package was installed from   will be always used for upgrade. (Allowed to be used more than once)</li> </ul> <pre><code>pixi global upgrade ruff\npixi global upgrade --channel conda-forge --channel bioconda trackplot\n# Or in a more concise form\npixi global upgrade -c conda-forge -c bioconda trackplot\n\n# Conda matchspec is supported\n# You can specify the version to upgrade to when you don't want the latest version\n# or you can even use it to downgrade a globally installed package\npixi global upgrade python=3.10\n</code></pre>"},{"location":"reference/cli/#global-upgrade-all","title":"<code>global upgrade-all</code>","text":"<p>This command upgrades all globally installed packages to their latest version.</p>"},{"location":"reference/cli/#options_22","title":"Options","text":"<ul> <li><code>--channel &lt;CHANNEL&gt; (-c)</code>: specify a channel that the project uses.   Defaults to <code>conda-forge</code>. Note the channel the package was installed from   will be always used for upgrade. (Allowed to be used more than once)</li> </ul> <pre><code>pixi global upgrade-all\npixi global upgrade-all --channel conda-forge --channel bioconda\n# Or in a more concise form\npixi global upgrade-all -c conda-forge -c bioconda trackplot\n</code></pre>"},{"location":"reference/cli/#global-remove","title":"<code>global remove</code>","text":"<p>Removes a package previously installed into a globally accessible location via <code>pixi global install</code></p> <p>Use <code>pixi global info</code> to find out what the package name is that belongs to the tool you want to remove.</p>"},{"location":"reference/cli/#arguments_19","title":"Arguments","text":"<ol> <li><code>&lt;PACKAGE&gt;</code>: The package(s) to remove.</li> </ol> <pre><code>pixi global remove pre-commit\n\n# multiple packages can be removed at once\npixi global remove pre-commit starship\n</code></pre>"},{"location":"reference/cli/#project","title":"<code>project</code>","text":"<p>This subcommand allows you to modify the project configuration through the command line interface.</p>"},{"location":"reference/cli/#options_23","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to manifest file, by default it searches for one in the parent directories.</li> </ul>"},{"location":"reference/cli/#project-channel-add","title":"<code>project channel add</code>","text":"<p>Add channels to the channel list in the project configuration. When you add channels, the channels are tested for existence, added to the lock file and the environment is reinstalled.</p>"},{"location":"reference/cli/#arguments_20","title":"Arguments","text":"<ol> <li><code>&lt;CHANNEL&gt;</code>: The channels to add, name or URL.</li> </ol>"},{"location":"reference/cli/#options_24","title":"Options","text":"<ul> <li><code>--no-install</code>: do not update the environment, only add changed packages to the lock-file.</li> <li><code>--feature &lt;FEATURE&gt; (-f)</code>: The feature for which the channel is added.</li> </ul> <pre><code>pixi project channel add robostack\npixi project channel add bioconda conda-forge robostack\npixi project channel add file:///home/user/local_channel\npixi project channel add https://repo.prefix.dev/conda-forge\npixi project channel add --no-install robostack\npixi project channel add --feature cuda nividia\n</code></pre>"},{"location":"reference/cli/#project-channel-list","title":"<code>project channel list</code>","text":"<p>List the channels in the project file</p>"},{"location":"reference/cli/#options_25","title":"Options","text":"<ul> <li><code>urls</code>: show the urls of the channels instead of the names.</li> </ul> <pre><code>$ pixi project channel list\nEnvironment: default\n- conda-forge\n\n$ pixi project channel list --urls\nEnvironment: default\n- https://conda.anaconda.org/conda-forge/\n</code></pre>"},{"location":"reference/cli/#project-channel-remove","title":"<code>project channel remove</code>","text":"<p>List the channels in the project file</p>"},{"location":"reference/cli/#arguments_21","title":"Arguments","text":"<ol> <li><code>&lt;CHANNEL&gt;...</code>: The channels to remove, name(s) or URL(s).</li> </ol>"},{"location":"reference/cli/#options_26","title":"Options","text":"<ul> <li><code>--no-install</code>: do not update the environment, only add changed packages to the lock-file.</li> <li><code>--feature &lt;FEATURE&gt; (-f)</code>: The feature for which the channel is removed.</li> </ul> <pre><code>pixi project channel remove conda-forge\npixi project channel remove https://conda.anaconda.org/conda-forge/\npixi project channel remove --no-install conda-forge\npixi project channel remove --feature cuda nividia\n</code></pre>"},{"location":"reference/cli/#project-description-get","title":"<code>project description get</code>","text":"<p>Get the project description.</p> <pre><code>$ pixi project description get\nPackage management made easy!\n</code></pre>"},{"location":"reference/cli/#project-description-set","title":"<code>project description set</code>","text":"<p>Set the project description.</p>"},{"location":"reference/cli/#arguments_22","title":"Arguments","text":"<ol> <li><code>&lt;DESCRIPTION&gt;</code>: The description to set.</li> </ol> <pre><code>pixi project description set \"my new description\"\n</code></pre>"},{"location":"reference/cli/#project-platform-add","title":"<code>project platform add</code>","text":"<p>Adds a platform(s) to the project file and updates the lock file.</p>"},{"location":"reference/cli/#arguments_23","title":"Arguments","text":"<ol> <li><code>&lt;PLATFORM&gt;...</code>: The platforms to add.</li> </ol>"},{"location":"reference/cli/#options_27","title":"Options","text":"<ul> <li><code>--no-install</code>: do not update the environment, only add changed packages to the lock-file.</li> <li><code>--feature &lt;FEATURE&gt; (-f)</code>: The feature for which the platform will be added.</li> </ul> <pre><code>pixi project platform add win-64\npixi project platform add --feature test win-64\n</code></pre>"},{"location":"reference/cli/#project-platform-list","title":"<code>project platform list</code>","text":"<p>List the platforms in the project file.</p> <pre><code>$ pixi project platform list\nosx-64\nlinux-64\nwin-64\nosx-arm64\n</code></pre>"},{"location":"reference/cli/#project-platform-remove","title":"<code>project platform remove</code>","text":"<p>Remove platform(s) from the project file and updates the lock file.</p>"},{"location":"reference/cli/#arguments_24","title":"Arguments","text":"<ol> <li><code>&lt;PLATFORM&gt;...</code>: The platforms to remove.</li> </ol>"},{"location":"reference/cli/#options_28","title":"Options","text":"<ul> <li><code>--no-install</code>: do not update the environment, only add changed packages to the lock-file.</li> <li><code>--feature &lt;FEATURE&gt; (-f)</code>: The feature for which the platform will be removed.</li> </ul> <pre><code>pixi project platform remove win-64\npixi project platform remove --feature test win-64\n</code></pre>"},{"location":"reference/cli/#project-version-get","title":"<code>project version get</code>","text":"<p>Get the project version.</p> <pre><code>$ pixi project version get\n0.11.0\n</code></pre>"},{"location":"reference/cli/#project-version-set","title":"<code>project version set</code>","text":"<p>Set the project version.</p>"},{"location":"reference/cli/#arguments_25","title":"Arguments","text":"<ol> <li><code>&lt;VERSION&gt;</code>: The version to set.</li> </ol> <pre><code>pixi project version set \"0.13.0\"\n</code></pre>"},{"location":"reference/cli/#project-version-majorminorpatch","title":"<code>project version {major|minor|patch}</code>","text":"<p>Bump the project version to {MAJOR|MINOR|PATCH}.</p> <pre><code>pixi project version major\npixi project version minor\npixi project version patch\n</code></pre> <ol> <li> <p>An up-to-date lock file means that the dependencies in the lock file are allowed by the dependencies in the manifest file. For example</p> <ul> <li>a manifest with <code>python = \"&gt;= 3.11\"</code> is up-to-date with a <code>name: python, version: 3.11.0</code> in the <code>pixi.lock</code>.</li> <li>a manifest with <code>python = \"&gt;= 3.12\"</code> is not up-to-date with a <code>name: python, version: 3.11.0</code> in the <code>pixi.lock</code>.</li> </ul> <p>Being up-to-date does not mean that the lock file holds the latest version available on the channel for the given dependency.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"reference/configuration/","title":"Configuration","text":"<p>The <code>pixi.toml</code> is the pixi project configuration file, also known as the project manifest.</p> <p>A <code>toml</code> file is structured in different tables. This document will explain the usage of the different tables. For more technical documentation check pixi on crates.io.</p> <p>Tip</p> <p>We also support the <code>pyproject.toml</code> file. It has the same structure as the <code>pixi.toml</code> file. except that you need to prepend the tables with <code>tool.pixi</code> instead of just the table name. For example, the <code>[project]</code> table becomes <code>[tool.pixi.project]</code>. There are also some small extras that are available in the <code>pyproject.toml</code> file, checkout the pyproject.toml documentation for more information.</p>"},{"location":"reference/configuration/#the-project-table","title":"The <code>project</code> table","text":"<p>The minimally required information in the <code>project</code> table is:</p> <pre><code>[project]\nname = \"project-name\"\nchannels = [\"conda-forge\"]\nplatforms = [\"linux-64\"]\n</code></pre>"},{"location":"reference/configuration/#name","title":"<code>name</code>","text":"<p>The name of the project.</p> <pre><code>name = \"project-name\"\n</code></pre>"},{"location":"reference/configuration/#channels","title":"<code>channels</code>","text":"<p>This is a list that defines the channels used to fetch the packages from. If you want to use channels hosted on <code>anaconda.org</code> you only need to use the name of the channel directly.</p> <pre><code>channels = [\"conda-forge\", \"robostack\", \"bioconda\", \"nvidia\", \"pytorch\"]\n</code></pre> <p>Channels situated on the file system are also supported with absolute file paths:</p> <pre><code>channels = [\"conda-forge\", \"file:///home/user/staged-recipes/build_artifacts\"]\n</code></pre> <p>To access private or public channels on prefix.dev or Quetz use the url including the hostname:</p> <pre><code>channels = [\"conda-forge\", \"https://repo.prefix.dev/channel-name\"]\n</code></pre>"},{"location":"reference/configuration/#platforms","title":"<code>platforms</code>","text":"<p>Defines the list of platforms that the project supports. Pixi solves the dependencies for all these platforms and puts them in the lock file (<code>pixi.lock</code>).</p> <pre><code>platforms = [\"win-64\", \"linux-64\", \"osx-64\", \"osx-arm64\"]\n</code></pre> <p>The available platforms are listed here: link</p>"},{"location":"reference/configuration/#version-optional","title":"<code>version</code> (optional)","text":"<p>The version of the project. This should be a valid version based on the conda Version Spec. See the version documentation, for an explanation of what is allowed in a Version Spec.</p> <pre><code>version = \"1.2.3\"\n</code></pre>"},{"location":"reference/configuration/#authors-optional","title":"<code>authors</code> (optional)","text":"<p>This is a list of authors of the project.</p> <pre><code>authors = [\"John Doe &lt;j.doe@prefix.dev&gt;\", \"Marie Curie &lt;mss1867@gmail.com&gt;\"]\n</code></pre>"},{"location":"reference/configuration/#description-optional","title":"<code>description</code> (optional)","text":"<p>This should contain a short description of the project.</p> <pre><code>description = \"A simple description\"\n</code></pre>"},{"location":"reference/configuration/#license-optional","title":"<code>license</code> (optional)","text":"<p>The license as a valid SPDX string (e.g. MIT AND Apache-2.0)</p> <pre><code>license = \"MIT\"\n</code></pre>"},{"location":"reference/configuration/#license-file-optional","title":"<code>license-file</code> (optional)","text":"<p>Relative path to the license file.</p> <pre><code>license-file = \"LICENSE.md\"\n</code></pre>"},{"location":"reference/configuration/#readme-optional","title":"<code>readme</code> (optional)","text":"<p>Relative path to the README file.</p> <pre><code>readme = \"README.md\"\n</code></pre>"},{"location":"reference/configuration/#homepage-optional","title":"<code>homepage</code> (optional)","text":"<p>URL of the project homepage.</p> <pre><code>homepage = \"https://pixi.sh\"\n</code></pre>"},{"location":"reference/configuration/#repository-optional","title":"<code>repository</code> (optional)","text":"<p>URL of the project source repository.</p> <pre><code>repository = \"https://github.com/prefix-dev/pixi\"\n</code></pre>"},{"location":"reference/configuration/#documentation-optional","title":"<code>documentation</code> (optional)","text":"<p>URL of the project documentation.</p> <pre><code>documentation = \"https://pixi.sh\"\n</code></pre>"},{"location":"reference/configuration/#conda-pypi-map-optional","title":"<code>conda-pypi-map</code> (optional)","text":"<p>Mapping of channel name or URL to location of mapping that can be URL/Path. Mapping should be structured in <code>json</code> format where <code>conda_name</code>: <code>pypi_package_name</code>. Example:</p> local/robostack_mapping.json<pre><code>{\n  \"jupyter-ros\": \"my-name-from-mapping\",\n  \"boltons\": \"boltons-pypi\"\n}\n</code></pre> <p>If <code>conda-forge</code> is not present in <code>conda-pypi-map</code> <code>pixi</code> will use <code>prefix.dev</code> mapping for it.</p> <pre><code>conda-pypi-map = { \"conda-forge\" = \"https://example.com/mapping\", \"https://repo.prefix.dev/robostack\" = \"local/robostack_mapping.json\"}\n</code></pre>"},{"location":"reference/configuration/#the-tasks-table","title":"The <code>tasks</code> table","text":"<p>Tasks are a way to automate certain custom commands in your project. For example, a <code>lint</code> or <code>format</code> step. Tasks in a pixi project are essentially cross-platform shell commands, with a unified syntax across platforms. For more in-depth information, check the Advanced tasks documentation. Pixi's tasks are run in a pixi environment using <code>pixi run</code> and are executed using the <code>deno_task_shell</code>.</p> <pre><code>[tasks]\nsimple = \"echo This is a simple task\"\ncmd = { cmd=\"echo Same as a simple task but now more verbose\"}\ndepending = { cmd=\"echo run after simple\", depends-on=\"simple\"}\nalias = { depends-on=[\"depending\"]}\ndownload = { cmd=\"curl -o file.txt https://example.com/file.txt\" , outputs=[\"file.txt\"]}\nbuild = { cmd=\"npm build\", cwd=\"frontend\", inputs=[\"frontend/package.json\", \"frontend/*.js\"]}\nrun = { cmd=\"python run.py $ARGUMENT\", env={ ARGUMENT=\"value\" }}\n</code></pre> <p>You can modify this table using <code>pixi task</code>.</p> <p>Note</p> <p>Specify different tasks for different platforms using the target table</p> <p>Info</p> <p>If you want to hide a task from showing up with <code>pixi task list</code> or <code>pixi info</code>, you can prefix the name with <code>_</code>. For example, if you want to hide <code>depending</code>, you can rename it to <code>_depending</code>.</p>"},{"location":"reference/configuration/#the-system-requirements-table","title":"The <code>system-requirements</code> table","text":"<p>The system requirements are used to define minimal system specifications used during dependency resolution. For example, we can define a unix system with a specific minimal libc version. This will be the minimal system specification for the project. System specifications are directly related to the virtual packages.</p> <p>Currently, the specified defaults are the same as conda-lock's implementation:</p> LinuxWindowsOsxOsx-arm64 default system requirements for linux<pre><code>[system-requirements]\nlinux = \"5.10\"\nlibc = { family=\"glibc\", version=\"2.17\" }\n</code></pre> default system requirements for windows<pre><code>[system-requirements]\n</code></pre> default system requirements for osx<pre><code>[system-requirements]\nmacos = \"10.15\"\n</code></pre> default system requirements for osx-arm64<pre><code>[system-requirements]\nmacos = \"11.0\"\n</code></pre> <p>Only if a project requires a different set should you define them.</p> <p>For example, when installing environments on old versions of linux. You may encounter the following error:</p> <pre><code>\u00d7 The current system has a mismatching virtual package. The project requires '__linux' to be at least version '5.10' but the system has version '4.12.14'\n</code></pre> <p>This suggests that the system requirements for the project should be lowered. To fix this, add the following table to your configuration:</p> <pre><code>[system-requirements]\nlinux = \"4.12.14\"\n</code></pre>"},{"location":"reference/configuration/#using-cuda-in-pixi","title":"Using Cuda in pixi","text":"<p>If you want to use <code>cuda</code> in your project you need to add the following to your <code>system-requirements</code> table:</p> <pre><code>[system-requirements]\ncuda = \"11\" # or any other version of cuda you want to use\n</code></pre> <p>This informs the solver that cuda is going to be available, so it can lock it into the lock file if needed.</p>"},{"location":"reference/configuration/#the-pypi-options-table","title":"The <code>pypi-options</code> table","text":"<p>The <code>pypi-options</code> table is used to define options that are specific to PyPI registries. These options can be specified either at the root level, which will add it to the default options feature, or on feature level, which will create a union of these options when the features are included in the environment.</p>"},{"location":"reference/configuration/#alternative-registries","title":"Alternative registries","text":"<p>Currently the main reason to use this table is to define alternative registries. We support:</p> <ul> <li><code>index-url</code>: replaces the main index url.    Only one <code>index-url</code> can be defined per environment.</li> <li><code>extra-index-urls</code>: adds an extra index url.</li> <li><code>find-links</code>: which can either be a path <code>{path: './links'}</code> or a url <code>{url: 'https://example.com/links'}</code>.    This is similar to the <code>--find-links</code> option in <code>pip</code>.</li> </ul> <p>An example:</p> <pre><code>[pypi-options]\nindex-url = \"https://pypi.org/simple\"\nextra-index-urls = [\"https://example.com/simple\"]\nfind-links = [{path: './links'}]\n</code></pre> <p>There are some examples in the pixi repository that make use of this feature. To read about existing authentication methods, please check the PyPI Authentication section.</p> <p>Strict Index Priority</p> <p>Unlike pip, because we make use of uv, we have a strict index priority. This means that the first index is used where a package can be found. The order is determined by the order in the toml file. Where the <code>extra-index-urls</code> are preferred over the <code>index-url</code>. Read more about this on the UV Readme</p>"},{"location":"reference/configuration/#the-dependencies-tables","title":"The <code>dependencies</code> table(s)","text":"<p>This section defines what dependencies you would like to use for your project.</p> <p>There are multiple dependencies tables. The default is <code>[dependencies]</code>, which are dependencies that are shared across platforms.</p> <p>Dependencies are defined using a VersionSpec. A <code>VersionSpec</code> combines a Version with an optional operator.</p> <p>Some examples are:</p> <pre><code># Use this exact package version\npackage0 = \"1.2.3\"\n# Use 1.2.3 up to 1.3.0\npackage1 = \"~=1.2.3\"\n# Use larger than 1.2 lower and equal to 1.4\npackage2 = \"&gt;1.2,&lt;=1.4\"\n# Bigger or equal than 1.2.3 or lower not including 1.0.0\npackage3 = \"&gt;=1.2.3|&lt;1.0.0\"\n</code></pre> <p>Dependencies can also be defined as a mapping where it is using a matchspec:</p> <pre><code>package0 = { version = \"&gt;=1.2.3\", channel=\"conda-forge\" }\npackage1 = { version = \"&gt;=1.2.3\", build=\"py34_0\" }\n</code></pre> <p>Tip</p> <p>The dependencies can be easily added using the <code>pixi add</code> command line. Running <code>add</code> for an existing dependency will replace it with the newest it can use.</p> <p>Note</p> <p>To specify different dependencies for different platforms use the target table</p>"},{"location":"reference/configuration/#dependencies","title":"<code>dependencies</code>","text":"<p>Add any conda package dependency that you want to install into the environment. Don't forget to add the channel to the project table should you use anything different than <code>conda-forge</code>. Even if the dependency defines a channel that channel should be added to the <code>project.channels</code> list.</p> <pre><code>[dependencies]\npython = \"&gt;3.9,&lt;=3.11\"\nrust = \"1.72\"\npytorch-cpu = { version = \"~=1.1\", channel = \"pytorch\" }\n</code></pre>"},{"location":"reference/configuration/#pypi-dependencies","title":"<code>pypi-dependencies</code>","text":"Details regarding the PyPI integration <p>We use <code>uv</code>, which is a new fast pip replacement written in Rust.</p> <p>We integrate uv as a library, so we use the uv resolver, to which we pass the conda packages as 'locked'. This disallows uv from installing these dependencies itself, and  ensures it uses the exact version of these packages in the resolution. This is unique amongst conda based package managers, which usually just call pip from a subprocess.</p> <p>The uv resolution is included in the lock file directly.</p> <p>Pixi directly supports depending on PyPI packages, the PyPA calls a distributed package a 'distribution'. There are Source and Binary distributions both of which are supported by pixi. These distributions are installed into the environment after the conda environment has been resolved and installed. PyPI packages are not indexed on prefix.dev but can be viewed on pypi.org.</p> <p>Important considerations</p> <ul> <li>Stability: PyPI packages might be less stable than their conda counterparts. Prefer using conda packages in the <code>dependencies</code> table where possible.</li> <li>Compatibility limitation: Currently, pixi doesn't support private PyPI repositories</li> </ul>"},{"location":"reference/configuration/#version-specification","title":"Version specification:","text":"<p>These dependencies don't follow the conda matchspec specification. The <code>version</code> is a string specification of the version according to PEP404/PyPA. Additionally, a list of extra's can be included, which are essentially optional dependencies. Note that this <code>version</code> is distinct from the conda MatchSpec type. See the example below to see how this is used in practice:</p> <pre><code>[dependencies]\n# When using pypi-dependencies, python is needed to resolve pypi dependencies\n# make sure to include this\npython = \"&gt;=3.6\"\n\n[pypi-dependencies]\nfastapi = \"*\"  # This means any version (the wildcard `*` is a pixi addition, not part of the specification)\npre-commit = \"~=3.5.0\" # This is a single version specifier\n# Using the toml map allows the user to add `extras`\npandas = { version = \"&gt;=1.0.0\", extras = [\"dataframe\", \"sql\"]}\n\n# git dependencies\n# With ssh\nflask = { git = \"ssh://git@github.com/pallets/flask\" }\n# With https and a specific revision\nrequests = { git = \"https://github.com/psf/requests.git\", rev = \"0106aced5faa299e6ede89d1230bd6784f2c3660\" }\n# TODO: will support later -&gt; branch = '' or tag = '' to specify a branch or tag\n\n# You can also directly add a source dependency from a path, tip keep this relative to the root of the project.\nminimal-project = { path = \"./minimal-project\", editable = true}\n\n# You can also use a direct url, to either a `.tar.gz` or `.zip`, or a `.whl` file\nclick = { url = \"https://github.com/pallets/click/releases/download/8.1.7/click-8.1.7-py3-none-any.whl\" }\n\n# You can also just the default git repo, it will checkout the default branch\npytest = { git = \"https://github.com/pytest-dev/pytest.git\"}\n</code></pre>"},{"location":"reference/configuration/#full-specification","title":"Full specification","text":"<p>The full specification of a PyPI dependencies that pixi supports can be split into the following fields:</p>"},{"location":"reference/configuration/#extras","title":"<code>extras</code>","text":"<p>A list of extras to install with the package. e.g. <code>[\"dataframe\", \"sql\"]</code> The extras field works with all other version specifiers as it is an addition to the version specifier.</p> <pre><code>pandas = { version = \"&gt;=1.0.0\", extras = [\"dataframe\", \"sql\"]}\npytest = { git = \"URL\", extras = [\"dev\"]}\nblack = { url = \"URL\", extras = [\"cli\"]}\nminimal-project = { path = \"./minimal-project\", editable = true, extras = [\"dev\"]}\n</code></pre>"},{"location":"reference/configuration/#version","title":"<code>version</code>","text":"<p>The version of the package to install. e.g. <code>\"&gt;=1.0.0\"</code> or <code>*</code> which stands for any version, this is pixi specific. Version is our default field so using no inline table (<code>{}</code>) will default to this field.</p> <pre><code>py-rattler = \"*\"\nruff = \"~=1.0.0\"\npytest = {version = \"*\", extras = [\"dev\"]}\n</code></pre>"},{"location":"reference/configuration/#git","title":"<code>git</code>","text":"<p>A git repository to install from. This support both https:// and ssh:// urls.</p> <p>Use <code>git</code> in combination with <code>rev</code> or <code>subdirectory</code>:</p> <ul> <li><code>rev</code>: A specific revision to install. e.g. <code>rev = \"0106aced5faa299e6ede89d1230bd6784f2c3660</code></li> <li><code>subdirectory</code>: A subdirectory to install from. <code>subdirectory = \"src\"</code> or <code>subdirectory = \"src/packagex\"</code></li> </ul> <pre><code># Note don't forget the `ssh://` or `https://` prefix!\npytest = { git = \"https://github.com/pytest-dev/pytest.git\"}\nrequests = { git = \"https://github.com/psf/requests.git\", rev = \"0106aced5faa299e6ede89d1230bd6784f2c3660\" }\npy-rattler = { git = \"ssh://git@github.com:mamba-org/rattler.git\", subdirectory = \"py-rattler\" }\n</code></pre>"},{"location":"reference/configuration/#path","title":"<code>path</code>","text":"<p>A local path to install from. e.g. <code>path = \"./path/to/package\"</code> We would advise to keep your path projects in the project, and to use a relative path.</p> <p>Set <code>editable</code> to <code>true</code> to install in editable mode, this is highly recommended as it is hard to reinstall if you're not using editable mode. e.g. <code>editable = true</code></p> <pre><code>minimal-project = { path = \"./minimal-project\", editable = true}\n</code></pre>"},{"location":"reference/configuration/#url","title":"<code>url</code>","text":"<p>A URL to install a wheel or sdist directly from an url.</p> <pre><code>pandas = {url = \"https://files.pythonhosted.org/packages/3d/59/2afa81b9fb300c90531803c0fd43ff4548074fa3e8d0f747ef63b3b5e77a/pandas-2.2.1.tar.gz\"}\n</code></pre> Did you know you can use: <code>add --pypi</code>? <p>Use the <code>--pypi</code> flag with the <code>add</code> command to quickly add PyPI packages from the CLI. E.g <code>pixi add --pypi flask</code></p> <p>This does not support all the features of the <code>pypi-dependencies</code> table yet.</p>"},{"location":"reference/configuration/#source-dependencies-sdist","title":"Source dependencies (<code>sdist</code>)","text":"<p>The Source Distribution Format is a source based format (sdist for short), that a package can include alongside the binary wheel format. Because these distributions need to be built, the need a python executable to do this. This is why python needs to be present in a conda environment. Sdists usually depend on system packages to be built, especially when compiling C/C++ based python bindings. Think for example of Python SDL2 bindings depending on the C library: SDL2. To help built these dependencies we activate the conda environment that includes these pypi dependencies before resolving. This way when a source distribution depends on <code>gcc</code> for example, it's used from the conda environment instead of the system.</p>"},{"location":"reference/configuration/#host-dependencies","title":"<code>host-dependencies</code>","text":"<p>This table contains dependencies that are needed to build your project but which should not be included when your project is installed as part of another project. In other words, these dependencies are available during the build but are no longer available when your project is installed. Dependencies listed in this table are installed for the architecture of the target machine.</p> <pre><code>[host-dependencies]\npython = \"~=3.10.3\"\n</code></pre> <p>Typical examples of host dependencies are:</p> <ul> <li>Base interpreters: a Python package would list <code>python</code> here and an R package would list <code>mro-base</code> or <code>r-base</code>.</li> <li>Libraries your project links against during compilation like <code>openssl</code>, <code>rapidjson</code>, or <code>xtensor</code>.</li> </ul>"},{"location":"reference/configuration/#build-dependencies","title":"<code>build-dependencies</code>","text":"<p>This table contains dependencies that are needed to build the project. Different from <code>dependencies</code> and <code>host-dependencies</code> these packages are installed for the architecture of the build machine. This enables cross-compiling from one machine architecture to another.</p> <pre><code>[build-dependencies]\ncmake = \"~=3.24\"\n</code></pre> <p>Typical examples of build dependencies are:</p> <ul> <li>Compilers are invoked on the build machine, but they generate code for the target machine.   If the project is cross-compiled, the architecture of the build and target machine might differ.</li> <li><code>cmake</code> is invoked on the build machine to generate additional code- or project-files which are then include in the compilation process.</li> </ul> <p>Info</p> <p>The build target refers to the machine that will execute the build. Programs and libraries installed by these dependencies will be executed on the build machine.</p> <p>For example, if you compile on a MacBook with an Apple Silicon chip but target Linux x86_64 then your build platform is <code>osx-arm64</code> and your host platform is <code>linux-64</code>.</p>"},{"location":"reference/configuration/#the-activation-table","title":"The <code>activation</code> table","text":"<p>If you want to run an activation script inside the environment when either doing a <code>pixi run</code> or <code>pixi shell</code> these can be defined here. The scripts defined in this table will be sourced when the environment is activated using <code>pixi run</code> or <code>pixi shell</code></p> <p>Note</p> <p>The activation scripts are run by the system shell interpreter as they run before an environment is available. This means that it runs as <code>cmd.exe</code> on windows and <code>bash</code> on linux and osx (Unix). Only <code>.sh</code>, <code>.bash</code> and <code>.bat</code> files are supported.</p> <p>If you have scripts per platform use the target table.</p> <pre><code>[activation]\nscripts = [\"env_setup.sh\"]\n# To support windows platforms as well add the following\n[target.win-64.activation]\nscripts = [\"env_setup.bat\"]\n</code></pre>"},{"location":"reference/configuration/#the-target-table","title":"The <code>target</code> table","text":"<p>The target table is a table that allows for platform specific configuration. Allowing you to make different sets of tasks or dependencies per platform.</p> <p>The target table is currently implemented for the following sub-tables:</p> <ul> <li><code>activation</code></li> <li><code>dependencies</code></li> <li><code>tasks</code></li> </ul> <p>The target table is defined using <code>[target.PLATFORM.SUB-TABLE]</code>. E.g <code>[target.linux-64.dependencies]</code></p> <p>The platform can be any of:</p> <ul> <li><code>win</code>, <code>osx</code>, <code>linux</code> or <code>unix</code> (<code>unix</code> matches <code>linux</code> and <code>osx</code>)</li> <li>or any of the (more) specific target platforms, e.g. <code>linux-64</code>, <code>osx-arm64</code></li> </ul> <p>The sub-table can be any of the specified above.</p> <p>To make it a bit more clear, let's look at an example below. Currently, pixi combines the top level tables like <code>dependencies</code> with the target-specific ones into a single set. Which, in the case of dependencies, can both add or overwrite dependencies. In the example below, we have <code>cmake</code> being used for all targets but on <code>osx-64</code> or <code>osx-arm64</code> a different version of python will be selected.</p> <pre><code>[dependencies]\ncmake = \"3.26.4\"\npython = \"3.10\"\n\n[target.osx.dependencies]\npython = \"3.11\"\n</code></pre> <p>Here are some more examples:</p> <pre><code>[target.win-64.activation]\nscripts = [\"setup.bat\"]\n\n[target.win-64.dependencies]\nmsmpi = \"~=10.1.1\"\n\n[target.win-64.build-dependencies]\nvs2022_win-64 = \"19.36.32532\"\n\n[target.win-64.tasks]\ntmp = \"echo $TEMP\"\n\n[target.osx-64.dependencies]\nclang = \"&gt;=16.0.6\"\n</code></pre>"},{"location":"reference/configuration/#the-feature-and-environments-tables","title":"The <code>feature</code> and <code>environments</code> tables","text":"<p>The <code>feature</code> table allows you to define features that can be used to create different <code>[environments]</code>. The <code>[environments]</code> table allows you to define different environments. The design is explained in the this design document.</p> Simplest example<pre><code>[feature.test.dependencies]\npytest = \"*\"\n\n[environments]\ntest = [\"test\"]\n</code></pre> <p>This will create an environment called <code>test</code> that has <code>pytest</code> installed.</p>"},{"location":"reference/configuration/#the-feature-table","title":"The <code>feature</code> table","text":"<p>The <code>feature</code> table allows you to define the following fields per feature.</p> <ul> <li><code>dependencies</code>: Same as the dependencies.</li> <li><code>pypi-dependencies</code>: Same as the pypi-dependencies.</li> <li><code>system-requirements</code>: Same as the system-requirements.</li> <li><code>activation</code>: Same as the activation.</li> <li><code>platforms</code>: Same as the platforms. Unless overridden, the <code>platforms</code> of the feature will be those defined at project level.</li> <li><code>channels</code>: Same as the channels. Unless overridden, the <code>channels</code> of the feature will be those defined at project level.</li> <li><code>target</code>: Same as the target.</li> <li><code>tasks</code>: Same as the tasks.</li> </ul> <p>These tables are all also available without the <code>feature</code> prefix. When those are used we call them the <code>default</code> feature. This is a protected name you can not use for your own feature.</p> Full feature table specification<pre><code>[feature.cuda]\nactivation = {scripts = [\"cuda_activation.sh\"]}\n# Results in:  [\"nvidia\", \"conda-forge\"] when the default is `conda-forge`\nchannels = [\"nvidia\"]\ndependencies = {cuda = \"x.y.z\", cudnn = \"12.0\"}\npypi-dependencies = {torch = \"==1.9.0\"}\nplatforms = [\"linux-64\", \"osx-arm64\"]\nsystem-requirements = {cuda = \"12\"}\ntasks = { warmup = \"python warmup.py\" }\ntarget.osx-arm64 = {dependencies = {mlx = \"x.y.z\"}}\n</code></pre> Full feature table but written as separate tables<pre><code>[feature.cuda.activation]\nscripts = [\"cuda_activation.sh\"]\n\n[feature.cuda.dependencies]\ncuda = \"x.y.z\"\ncudnn = \"12.0\"\n\n[feature.cuda.pypi-dependencies]\ntorch = \"==1.9.0\"\n\n[feature.cuda.system-requirements]\ncuda = \"12\"\n\n[feature.cuda.tasks]\nwarmup = \"python warmup.py\"\n\n[feature.cuda.target.osx-arm64.dependencies]\nmlx = \"x.y.z\"\n\n# Channels and Platforms are not available as separate tables as they are implemented as lists\n[feature.cuda]\nchannels = [\"nvidia\"]\nplatforms = [\"linux-64\", \"osx-arm64\"]\n</code></pre>"},{"location":"reference/configuration/#the-environments-table","title":"The <code>environments</code> table","text":"<p>The <code>[environments]</code> table allows you to define environments that are created using the features defined in the <code>[feature]</code> tables.</p> <p>The environments table is defined using the following fields:</p> <ul> <li><code>features</code>: The features that are included in the environment. Unless <code>no-default-feature</code> is set to <code>true</code>, the default feature is implicitly included in the environment.</li> <li><code>solve-group</code>: The solve group is used to group environments together at the solve stage.   This is useful for environments that need to have the same dependencies but might extend them with additional dependencies.   For instance when testing a production environment with additional test dependencies.   These dependencies will then be the same version in all environments that have the same solve group.   But the different environments contain different subsets of the solve-groups dependencies set.</li> <li><code>no-default-feature</code>: Whether to include the default feature in that environment. The default is <code>false</code>, to include the default feature.</li> </ul> <p>Full environments table specification<pre><code>[environments]\ntest = {features = [\"test\"], solve-group = \"test\"}\nprod = {features = [\"prod\"], solve-group = \"test\"}\nlint = {features = [\"lint\"], no-default-feature = true}\n</code></pre> As shown in the example above, in the simplest of cases, it is possible to define an environment only by listing its features:</p> Simplest example<pre><code>[environments]\ntest = [\"test\"]\n</code></pre> <p>is equivalent to</p> Simplest example expanded<pre><code>[environments]\ntest = {features = [\"test\"]}\n</code></pre> <p>When an environment comprises several features (including the default feature): - The <code>activation</code> and <code>tasks</code> of the environment are the union of the <code>activation</code> and <code>tasks</code> of all its features. - The <code>dependencies</code> and <code>pypi-dependencies</code> of the environment are the union of the <code>dependencies</code> and <code>pypi-dependencies</code> of all its features. This means that if several features define a requirement for the same package, both requirements will be combined. Beware of conflicting requirements across features added to the same environment. - The <code>system-requirements</code> of the environment is the union of the <code>system-requirements</code> of all its features. If multiple features specify a requirement for the same system package, the highest version is chosen. - The <code>channels</code> of the environment is the union of the <code>channels</code> of all its features. Channel priorities can be specified in each feature, to ensure channels are considered in the right order in the environment. - The <code>platforms</code> of the environment is the intersection of the <code>platforms</code> of all its features. Be aware that the platforms supported by a feature (including the default feature) will be considered as the <code>platforms</code> defined at project level (unless overridden in the feature). This means that it is usually a good idea to set the project <code>platforms</code> to all platforms it can support across its environments.</p>"},{"location":"reference/configuration/#global-configuration","title":"Global configuration","text":"<p>The global configuration options are documented in the global configuration section.</p>"},{"location":"tutorials/python/","title":"Tutorial: Doing Python development with Pixi","text":"<p>In this tutorial, we will show you how to create a simple Python project with pixi. We will show some of the features that pixi provides, that are currently not a part of <code>pdm</code>, <code>poetry</code> etc.</p>"},{"location":"tutorials/python/#why-is-this-useful","title":"Why is this useful?","text":"<p>Pixi builds upon the conda ecosystem, which allows you to create a Python environment with all the dependencies you need. This is especially useful when you are working with multiple Python interpreters and bindings to C and C++ libraries. For example, GDAL from PyPI does not have binary C dependencies, but the conda package does. On the other hand, some packages are only available through PyPI, which <code>pixi</code> can also install for you. Best of both world, let's give it a go!</p>"},{"location":"tutorials/python/#pixitoml-and-pyprojecttoml","title":"<code>pixi.toml</code> and <code>pyproject.toml</code>","text":"<p>We support two manifest formats: <code>pyproject.toml</code> and <code>pixi.toml</code>. In this tutorial, we will use the <code>pyproject.toml</code> format because it is the most common format for Python projects.</p>"},{"location":"tutorials/python/#lets-get-started","title":"Let's get started","text":"<p>Let's start out by making a directory and creating a new <code>pyproject.toml</code> file.</p> <pre><code>pixi init pixi_py --pyproject\n</code></pre> <p>This gives you the following pyproject.toml:</p> <pre><code>[project]\nname = \"pixi_py\"\nversion = \"0.1.0\"\ndescription = \"Add a short description here\"\nauthors = [{name = \"Tim de Jager\", email = \"tim@prefix.dev\"}]\nrequires-python = \"&gt;= 3.11\"\ndependencies = []\n\n[build-system]\nrequires = [\"setuptools\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.pixi.project]\nchannels = [\"conda-forge\"]\nplatforms = [\"osx-arm64\"]\n\n[tool.pixi.pypi-dependencies]\npixi_py = { path = \".\", editable = true }\n\n[tool.pixi.tasks]\n</code></pre> <p>Let's add the Python project to the tree:</p> Linux &amp; macOSWindows <pre><code>cd pixi_py # move into the project directory\nmkdir pixi_py\ntouch pixi_py/__init__.py\n</code></pre> <pre><code>cd pixi_py\nmkdir pixi_py\ntype nul &gt; pixi_py\\__init__.py\n</code></pre> <p>We now have the following directory structure:</p> <pre><code>.\n\u251c\u2500\u2500 pixi_py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2514\u2500\u2500 pyproject.toml\n</code></pre> <p>We've used a flat-layout here but pixi supports both flat- and src-layouts.</p>"},{"location":"tutorials/python/#whats-in-the-pyprojecttoml","title":"What's in the <code>pyproject.toml</code>?","text":"<p>Okay, so let's have a look at what's sections have been added and how we can modify the <code>pyproject.toml</code>.</p> <p>These first entries were added to the <code>pyproject.toml</code> file:</p> <pre><code># Main pixi entry\n[tool.pixi.project]\nchannels = [\"conda-forge\"]\n# This is your machine platform by default\nplatforms = [\"osx-arm64\"]\n</code></pre> <p>The <code>channels</code> and <code>platforms</code> are added to the <code>[tool.pixi.project]</code> section. Channels like <code>conda-forge</code> manage packages similar to PyPI but allow for different packages across languages. The keyword <code>platforms</code> determines what platform the project supports.</p> <p>The <code>pixi_py</code> package itself is added as an editable dependency. This means that the package is installed in editable mode, so you can make changes to the package and see the changes reflected in the environment, without having to re-install the environment.</p> <pre><code># Editable installs\n[tool.pixi.pypi-dependencies]\npixi_py = { path = \".\", editable = true }\n</code></pre> <p>In pixi, unlike other package managers, this is explicitly stated in the <code>pyproject.toml</code> file. The main reason being so that you can choose which environment this package should be included in.</p>"},{"location":"tutorials/python/#managing-both-conda-and-pypi-dependencies-in-pixi","title":"Managing both conda and PyPI dependencies in pixi","text":"<p>Our projects usually depend on other packages.</p> <pre><code>$ pixi add black\nAdded black\n</code></pre> <p>This will result in the following addition to the <code>pyproject.toml</code>:</p> <pre><code># Dependencies\n[tool.pixi.dependencies]\nblack = \"&gt;=24.4.2,&lt;24.5\"\n</code></pre> <p>But we can also be strict about the version that should be used with <code>pixi add black=24</code>, resulting in</p> <pre><code>[tool.pixi.dependencies]\nblack = \"24.*\"\n</code></pre> <p>Now, let's add some optional dependencies:</p> <pre><code>pixi add --pypi --feature test pytest\n</code></pre> <p>Which results in the following fields added to the <code>pyproject.toml</code>: <pre><code>[project.optional-dependencies]\ntest = [\"pytest\"]\n</code></pre></p> <p>After we have added the optional dependencies to the <code>pyproject.toml</code>, pixi automatically creates a <code>feature</code>, which can contain a collection of <code>dependencies</code>, <code>tasks</code>, <code>channels</code>, and more.</p> <p>Sometimes there are packages that aren't available on conda channels but are published on PyPI. We can add these as well, which pixi will solve together with the default dependencies.</p> <pre><code>$ pixi add black --pypi\nAdded black\nAdded these as pypi-dependencies.\n</code></pre> <p>which results in the addition to the <code>dependencies</code> key in the <code>pyproject.toml</code></p> <pre><code>dependencies = [\"black\"]\n</code></pre> <p>When using the <code>pypi-depenencies</code> you can make use of the <code>optional-dependencies</code> that other packages make available. For example, <code>black</code> makes the <code>cli</code> dependencies option, which can be added with the <code>--pypi</code> keyword:</p> <pre><code>$ pixi add black[cli] --pypi\nAdded black[cli]\nAdded these as pypi-dependencies.\n</code></pre> <p>which updates the <code>dependencies</code> entry to</p> <pre><code>dependencies = [\"black[cli]\"]\n</code></pre> Optional dependencies in <code>pixi.toml</code> <p>This tutorial focuses on the use of the <code>pyproject.toml</code>, but in case you're curious, the <code>pixi.toml</code> would contain the following entry after the installation of a PyPI package including an optional dependency: <pre><code>[pypi-dependencies]\nblack = { version = \"*\", extras = [\"cli\"] }\n</code></pre></p>"},{"location":"tutorials/python/#installation-pixi-install","title":"Installation: <code>pixi install</code>","text":"<p>Now let's <code>install</code> the project with <code>pixi install</code>:</p> <pre><code>$ pixi install\n\u2714 Project in /path/to/pixi_py is ready to use!\n</code></pre> <p>We now have a new directory called <code>.pixi</code> in the project root. This directory contains the environment that was created when we ran <code>pixi install</code>. The environment is a conda environment that contains the dependencies that we specified in the <code>pyproject.toml</code> file. We can also install the test environment with <code>pixi install -e test</code>. We can use these environments for executing code.</p> <p>We also have a new file called <code>pixi.lock</code> in the project root. This file contains the exact versions of the dependencies that were installed in the environment across platforms.</p>"},{"location":"tutorials/python/#whats-in-the-environment","title":"What's in the environment?","text":"<p>Using <code>pixi list</code>, you can see what's in the environment, this is essentially a nicer view on the lock file:</p> <pre><code>$ pixi list\nPackage          Version       Build               Size       Kind   Source\nbzip2            1.0.8         h93a5062_5          119.5 KiB  conda  bzip2-1.0.8-h93a5062_5.conda\nblack            24.4.2                            3.8 MiB    pypi   black-24.4.2-cp312-cp312-win_amd64.http.whl\nca-certificates  2024.2.2      hf0a4a13_0          152.1 KiB  conda  ca-certificates-2024.2.2-hf0a4a13_0.conda\nlibexpat         2.6.2         hebf3989_0          62.2 KiB   conda  libexpat-2.6.2-hebf3989_0.conda\nlibffi           3.4.2         h3422bc3_5          38.1 KiB   conda  libffi-3.4.2-h3422bc3_5.tar.bz2\nlibsqlite        3.45.2        h091b4b1_0          806 KiB    conda  libsqlite-3.45.2-h091b4b1_0.conda\nlibzlib          1.2.13        h53f4e23_5          47 KiB     conda  libzlib-1.2.13-h53f4e23_5.conda\nncurses          6.4.20240210  h078ce10_0          801 KiB    conda  ncurses-6.4.20240210-h078ce10_0.conda\nopenssl          3.2.1         h0d3ecfb_1          2.7 MiB    conda  openssl-3.2.1-h0d3ecfb_1.conda\npython           3.12.3        h4a7b5fc_0_cpython  12.6 MiB   conda  python-3.12.3-h4a7b5fc_0_cpython.conda\nreadline         8.2           h92ec313_1          244.5 KiB  conda  readline-8.2-h92ec313_1.conda\ntk               8.6.13        h5083fa2_1          3 MiB      conda  tk-8.6.13-h5083fa2_1.conda\ntzdata           2024a         h0c530f3_0          117 KiB    conda  tzdata-2024a-h0c530f3_0.conda\npixi_py          0.1.0                                        pypi   . (editable)\nxz               5.2.6         h57fd34a_0          230.2 KiB  conda  xz-5.2.6-h57fd34a_0.tar.bz2\n</code></pre> <p>Python</p> <p>The Python interpreter is also installed in the environment. This is because the Python interpreter version is read from the <code>requires-python</code> field in the <code>pyproject.toml</code> file. This is used to determine the Python version to install in the environment. This way, pixi automatically manages/bootstraps the Python interpreter for you, so no more <code>brew</code>, <code>apt</code> or other system install steps.</p> <p>Here, you can see the different conda and Pypi packages listed. As you can see, the <code>pixi_py</code> package that we are working on is installed in editable mode. Every environment in pixi is isolated but reuses files that are hard-linked from a central cache directory. This means that you can have multiple environments with the same packages but only have the individual files stored once on disk.</p> <p>We can create the <code>default</code> and <code>test</code> environments based on our own <code>test</code> feature from the <code>optional-dependency</code>:</p> <pre><code># Environments\n[tool.pixi.environments]\ndefault = { solve-group = \"default\" }\ntest = { features = [\"test\"], solve-group = \"default\" }\n</code></pre> Solve Groups <p>Solve groups are a way to group dependencies together. This is useful when you have multiple environments that share the same dependencies. For example, maybe <code>pytest</code> is a dependency that influences the dependencies of the <code>default</code> environment. By putting these in the same solve group, you ensure that the versions in <code>test</code> and <code>default</code> are exactly the same.</p> <p>The <code>default</code> environment is created when you run <code>pixi install</code>. The <code>test</code> environment is created from the optional dependencies in the <code>pyproject.toml</code> file. You can execute commands in this environment with e.g. <code>pixi run -e test python</code></p>"},{"location":"tutorials/python/#getting-code-to-run","title":"Getting code to run","text":"<p>Let's add some code to the <code>pixi_py</code> package. We will add a new function to the <code>pixi_py/__init__.py</code> file:</p> <pre><code>from rich import print\n\ndef hello():\n    return \"Hello, [bold magenta]World[/bold magenta]!\", \":vampire:\"\n\ndef say_hello():\n    print(*hello())\n</code></pre> <p>Now add the <code>rich</code> dependency from PyPI using: <code>pixi add --pypi rich</code>.</p> <p>Let's see if this works by running:</p> <pre><code>pixi r python -c \"import pixi_py; pixi_py.say_hello()\"\nHello, World! \ud83e\udddb\n</code></pre> Slow? <p>This might be slow(2 minutes) the first time because pixi installs the project, but it will be near instant the second time.</p> <p>Pixi runs the self installed Python interpreter. Then, we are importing the <code>pixi_py</code> package, which is installed in editable mode. The code calls the <code>say_hello</code> function that we just added. And it works! Cool!</p>"},{"location":"tutorials/python/#testing-this-code","title":"Testing this code","text":"<p>Okay, so let's add a test for this function. Let's add a <code>tests/test_me.py</code> file in the root of the project.</p> <p>Giving us the following project structure:</p> <pre><code>.\n\u251c\u2500\u2500 pixi.lock\n\u251c\u2500\u2500 pixi_py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 tests/test_me.py\n</code></pre> <pre><code>from pixi_py import hello\n\ndef test_pixi_py():\n    assert hello() == (\"Hello, [bold magenta]World[/bold magenta]!\", \":vampire:\")\n</code></pre> <p>Let's add an easy task for running the tests.</p> <pre><code>$ pixi task add --feature test test \"pytest\"\n\u2714 Added task `test`: pytest .\n</code></pre> <p>So pixi has a task system to make it easy to run commands. Similar to <code>npm</code> scripts or something you would specify in a <code>Justfile</code>.</p> Pixi tasks <p>Tasks are actually a pretty cool pixi feature that is powerful and runs in a cross-platform shell. You can do caching, dependencies and more. Read more about tasks in the tasks section.</p> <pre><code>$ pixi r test\n\u2728 Pixi task (test): pytest .\n================================================================================================= test session starts =================================================================================================\nplatform darwin -- Python 3.12.2, pytest-8.1.1, pluggy-1.4.0\nrootdir: /private/tmp/pixi_py\nconfigfile: pyproject.toml\ncollected 1 item\n\ntest_me.py .                                                                                                                                                                                                    [100%]\n\n================================================================================================== 1 passed in 0.00s =================================================================================================\n</code></pre> <p>Neat! It seems to be working!</p>"},{"location":"tutorials/python/#test-vs-default-environment","title":"Test vs Default environment","text":"<p>The interesting thing is if we compare the output of the two environments.</p> <pre><code>pixi list -e test\n# v.s. default environment\npixi list\n</code></pre> <p>Is that the test environment has:</p> <pre><code>package          version       build               size       kind   source\n...\npytest           8.1.1                             1.1 mib    pypi   pytest-8.1.1-py3-none-any.whl\n...\n</code></pre> <p>But the default environment is missing this package. This way, you can finetune your environments to only have the packages that are needed for that environment. E.g. you could also have a <code>dev</code> environment that has <code>pytest</code> and <code>ruff</code> installed, but you could omit these from the <code>prod</code> environment. There is a docker example that shows how to set up a minimal <code>prod</code> environment and copy from there.</p>"},{"location":"tutorials/python/#replacing-pypi-packages-with-conda-packages","title":"Replacing PyPI packages with conda packages","text":"<p>Last thing, pixi provides the ability for <code>pypi</code> packages to depend on <code>conda</code> packages. Let's confirm this with <code>pixi list</code>:</p> <pre><code>$ pixi list\nPackage          Version       Build               Size       Kind   Source\n...\npygments         2.17.2                            4.1 MiB    pypi   pygments-2.17.2-py3-none-any.http.whl\n...\n</code></pre> <p>Let's explicitly add <code>pygments</code> to the <code>pyproject.toml</code> file. Which is a dependency of the <code>rich</code> package.</p> <pre><code>pixi add pygments\n</code></pre> <p>This will add the following to the <code>pyproject.toml</code> file:</p> <pre><code>[tool.pixi.dependencies]\npygments = \"&gt;=2.17.2,&lt;2.18\"\n</code></pre> <p>We can now see that the <code>pygments</code> package is now installed as a conda package.</p> <pre><code>$ pixi list\nPackage          Version       Build               Size       Kind   Source\n...\npygments         2.17.2        pyhd8ed1ab_0        840.3 KiB  conda  pygments-2.17.2-pyhd8ed1ab_0.conda\n</code></pre> <p>This way, PyPI dependencies and conda dependencies can be mixed and matched to seamlessly interoperate.</p> <pre><code>$  pixi r python -c \"import pixi_py; pixi_py.say_hello()\"\nHello, World! \ud83e\udddb\n</code></pre> <p>And it still works!</p>"},{"location":"tutorials/python/#conclusion","title":"Conclusion","text":"<p>In this tutorial, you've seen how easy it is to use a <code>pyproject.toml</code> to manage your pixi dependencies and environments. We have also explored how to use PyPI and conda dependencies seamlessly together in the same project and install optional dependencies to manage Python packages.</p> <p>Hopefully, this provides a flexible and powerful way to manage your Python projects and a fertile base for further exploration with Pixi.</p> <p>Thanks for reading! Happy Coding \ud83d\ude80</p> <p>Any questions? Feel free to reach out or share this tutorial on X, join our Discord, send us an e-mail or follow our GitHub.</p>"},{"location":"tutorials/ros2/","title":"Tutorial: Develop a ROS 2 package with <code>pixi</code>","text":"<p>In this tutorial, we will show you how to develop a ROS 2 package using <code>pixi</code>. The tutorial is written to be executed from top to bottom, missing steps might result in errors.</p> <p>The audience for this tutorial is developers who are familiar with ROS 2 and how are interested to try pixi for their development workflow.</p>"},{"location":"tutorials/ros2/#prerequisites","title":"Prerequisites","text":"<ul> <li>You need to have <code>pixi</code> installed. If you haven't installed it yet, you can follow the instructions in the installation guide.   The crux of this tutorial is to show you only need pixi!</li> <li>On Windows, it's advised to enable Developer mode. Go to Settings -&gt; Update &amp; Security -&gt; For developers -&gt; Developer mode.</li> </ul> <p>If you're new to pixi, you can check out the basic usage guide. This will teach you the basics of pixi project within 3 minutes.</p>"},{"location":"tutorials/ros2/#create-a-pixi-project","title":"Create a pixi project.","text":"<pre><code>pixi init my_ros2_project -c robostack-staging -c conda-forge\ncd my_ros2_project\n</code></pre> <p>It should have created a directory structure like this:</p> <pre><code>my_ros2_project\n\u251c\u2500\u2500 .gitattributes\n\u251c\u2500\u2500 .gitignore\n\u2514\u2500\u2500 pixi.toml\n</code></pre> <p>The <code>pixi.toml</code> file is the manifest file for your project. It should look like this:</p> pixi.toml<pre><code>[project]\nname = \"my_ros2_project\"\nversion = \"0.1.0\"\ndescription = \"Add a short description here\"\nauthors = [\"User Name &lt;user.name@email.url&gt;\"]\nchannels = [\"robostack-staging\", \"conda-forge\"]\n# Your project can support multiple platforms, the current platform will be automatically added.\nplatforms = [\"linux-64\"]\n\n[tasks]\n\n[dependencies]\n</code></pre> <p>The <code>channels</code> you added to the <code>init</code> command are repositories of packages, you can search in these repositories through our prefix.dev website. The <code>platforms</code> are the systems you want to support, in pixi you can support multiple platforms, but you have to define which platforms, so pixi can test if those are supported for your dependencies. For the rest of the fields, you can fill them in as you see fit.</p>"},{"location":"tutorials/ros2/#add-ros-2-dependencies","title":"Add ROS 2 dependencies","text":"<p>To use a pixi project you don't need any dependencies on your system, all the dependencies you need should be added through pixi, so other users can use your project without any issues.</p> <p>Let's start with the <code>turtlesim</code> example</p> <pre><code>pixi add ros-humble-desktop ros-humble-turtlesim\n</code></pre> <p>This will add the <code>ros-humble-desktop</code> and <code>ros-humble-turtlesim</code> packages to your manifest. Depending on your internet speed this might take a minute, as it will also install ROS in your project folder (<code>.pixi</code>).</p> <p>Now run the <code>turtlesim</code> example.</p> <pre><code>pixi run ros2 run turtlesim turtlesim_node\n</code></pre> <p>Or use the <code>shell</code> command to start an activated environment in your terminal.</p> <pre><code>pixi shell\nros2 run turtlesim turtlesim_node\n</code></pre> <p>Congratulations you have ROS 2 running on your machine with pixi!</p> Some more fun with the turtle <p>To control the turtle you can run the following command in a new terminal <pre><code>cd my_ros2_project\npixi run ros2 run turtlesim turtle_teleop_key\n</code></pre></p> <p>Now you can control the turtle with the arrow keys on your keyboard. </p>"},{"location":"tutorials/ros2/#add-a-custom-python-node","title":"Add a custom Python node","text":"<p>As ros works with custom nodes, let's add a custom node to our project.</p> <pre><code>pixi run ros2 pkg create --build-type ament_python --destination-directory src --node-name my_node my_package\n</code></pre> <p>To build the package we need some more dependencies:</p> <pre><code>pixi add colcon-common-extensions \"setuptools&lt;=58.2.0\"\n</code></pre> <p>Add the created initialization script for the ros workspace to your manifest file.</p> <p>Then run the build command</p> <pre><code>pixi run colcon build\n</code></pre> <p>This will create a sourceable script in the <code>install</code> folder, you can source this script through an activation script to use your custom node. Normally this would be the script you add to your <code>.bashrc</code> but now you tell pixi to use it.</p> Linux &amp; macOSWindows pixi.toml<pre><code>[activation]\nscripts = [\"install/setup.sh\"]\n</code></pre> pixi.toml<pre><code>[activation]\nscripts = [\"install/setup.bat\"]\n</code></pre> Multi platform support <p>You can add multiple activation scripts for different platforms, so you can support multiple platforms with one project. Use the following example to add support for both Linux and Windows, using the target syntax.</p> <pre><code>[project]\nplatforms = [\"linux-64\", \"win-64\"]\n\n[activation]\nscripts = [\"install/setup.sh\"]\n[target.win-64.activation]\nscripts = [\"install/setup.bat\"]\n</code></pre> <p>Now you can run your custom node with the following command</p> <pre><code>pixi run ros2 run my_package my_node\n</code></pre>"},{"location":"tutorials/ros2/#simplify-the-user-experience","title":"Simplify the user experience","text":"<p>In <code>pixi</code> we have a feature called <code>tasks</code>, this allows you to define a task in your manifest file and run it with a simple command. Let's add a task to run the <code>turtlesim</code> example and the custom node.</p> <pre><code>pixi task add sim \"ros2 run turtlesim turtlesim_node\"\npixi task add build \"colcon build --symlink-install\"\npixi task add hello \"ros2 run my_package my_node\"\n</code></pre> <p>Now you can run these task by simply running</p> <pre><code>pixi run sim\npixi run build\npixi run hello\n</code></pre> Advanced task usage <p>Tasks are a powerful feature in pixi.</p> <ul> <li>You can add <code>depends-on</code> to the tasks to create a task chain.</li> <li>You can add <code>cwd</code> to the tasks to run the task in a different directory from the root of the project.</li> <li>You can add <code>inputs</code> and <code>outputs</code> to the tasks to create a task that only runs when the inputs are changed.</li> <li>You can use the <code>target</code> syntax to run specific tasks on specific machines.</li> </ul> <pre><code>[tasks]\nsim = \"ros2 run turtlesim turtlesim_node\"\nbuild = {cmd = \"colcon build --symlink-install\", inputs = [\"src\"]}\nhello = { cmd = \"ros2 run my_package my_node\", depends-on = [\"build\"] }\n</code></pre>"},{"location":"tutorials/ros2/#build-a-c-node","title":"Build a C++ node","text":"<p>To build a C++ node you need to add the <code>ament_cmake</code> and some other build dependencies to your manifest file.</p> <pre><code>pixi add ros-humble-ament-cmake-auto compilers pkg-config cmake ninja\n</code></pre> <p>Now you can create a C++ node with the following command</p> <pre><code>pixi run ros2 pkg create --build-type ament_cmake --destination-directory src --node-name my_cpp_node my_cpp_package\n</code></pre> <p>Now you can build it again and run it with the following commands</p> <pre><code># Passing arguments to the build command to build with Ninja, add them to the manifest if you want to default to ninja.\npixi run build --cmake-args -G Ninja\npixi run ros2 run my_cpp_package my_cpp_node\n</code></pre> Tip <p>Add the cpp task to the manifest file to simplify the user experience.</p> <pre><code>pixi task add hello-cpp \"ros2 run my_cpp_package my_cpp_node\"\n</code></pre>"},{"location":"tutorials/ros2/#conclusion","title":"Conclusion","text":"<p>In this tutorial, we showed you how to create a Python &amp; CMake ROS2 project using <code>pixi</code>. We also showed you how to add dependencies to your project using <code>pixi</code>, and how to run your project using <code>pixi run</code>. This way you can make sure that your project is reproducible on all your machines that have <code>pixi</code> installed.</p>"},{"location":"tutorials/ros2/#show-off-your-work","title":"Show Off Your Work!","text":"<p>Finished with your project? We'd love to see what you've created! Share your work on social media using the hashtag #pixi and tag us @prefix_dev. Let's inspire the community together!</p>"},{"location":"tutorials/ros2/#frequently-asked-questions","title":"Frequently asked questions","text":""},{"location":"tutorials/ros2/#what-happens-with-rosdep","title":"What happens with <code>rosdep</code>?","text":"<p>Currently, we don't support <code>rosdep</code> in a pixi environment, so you'll have to add the packages using <code>pixi add</code>. <code>rosdep</code> will call <code>conda install</code> which isn't supported in a pixi environment.</p>"},{"location":"tutorials/rust/","title":"Tutorial: Develop a Rust package using <code>pixi</code>","text":"<p>In this tutorial, we will show you how to develop a Rust package using <code>pixi</code>. The tutorial is written to be executed from top to bottom, missing steps might result in errors.</p> <p>The audience for this tutorial is developers who are familiar with Rust and <code>cargo</code> and how are interested to try pixi for their development workflow. The benefit would be within a rust workflow that you lock both rust and the C/System dependencies your project might be using. E.g tokio users will almost most definitely use <code>openssl</code>.</p> <p>If you're new to pixi, you can check out the basic usage guide. This will teach you the basics of pixi project within 3 minutes.</p>"},{"location":"tutorials/rust/#prerequisites","title":"Prerequisites","text":"<ul> <li>You need to have <code>pixi</code> installed. If you haven't installed it yet, you can follow the instructions in the installation guide.   The crux of this tutorial is to show you only need pixi!</li> </ul>"},{"location":"tutorials/rust/#create-a-pixi-project","title":"Create a pixi project.","text":"<pre><code>pixi init my_rust_project\ncd my_rust_project\n</code></pre> <p>It should have created a directory structure like this:</p> <pre><code>my_rust_project\n\u251c\u2500\u2500 .gitattributes\n\u251c\u2500\u2500 .gitignore\n\u2514\u2500\u2500 pixi.toml\n</code></pre> <p>The <code>pixi.toml</code> file is the manifest file for your project. It should look like this:</p> pixi.toml<pre><code>[project]\nname = \"my_rust_project\"\nversion = \"0.1.0\"\ndescription = \"Add a short description here\"\nauthors = [\"User Name &lt;user.name@email.url&gt;\"]\nchannels = [\"conda-forge\"]\nplatforms = [\"linux-64\"] # (1)!\n\n[tasks]\n\n[dependencies]\n</code></pre> <ol> <li>The <code>platforms</code> is set to your system's platform by default. You can change it to any platform you want to support. e.g. <code>[\"linux-64\", \"osx-64\", \"osx-arm64\", \"win-64\"]</code>.</li> </ol>"},{"location":"tutorials/rust/#add-rust-dependencies","title":"Add Rust dependencies","text":"<p>To use a pixi project you don't need any dependencies on your system, all the dependencies you need should be added through pixi, so other users can use your project without any issues. <pre><code>pixi add rust\n</code></pre></p> <p>This will add the <code>rust</code> package to your <code>pixi.toml</code> file under <code>[dependencies]</code>. Which includes the <code>rust</code> toolchain, and <code>cargo</code>.</p>"},{"location":"tutorials/rust/#add-a-cargo-project","title":"Add a <code>cargo</code> project","text":"<p>Now that you have rust installed, you can create a <code>cargo</code> project in your <code>pixi</code> project. <pre><code>pixi run cargo init\n</code></pre></p> <p><code>pixi run</code> is pixi's way to run commands in the <code>pixi</code> environment, it will make sure that the environment is set up correctly for the command to run. It runs its own cross-platform shell, if you want more information checkout the <code>tasks</code> documentation. You can also activate the environment in your own shell by running <code>pixi shell</code>, after that you don't need <code>pixi run ...</code> anymore.</p> <p>Now we can build a <code>cargo</code> project using <code>pixi</code>. <pre><code>pixi run cargo build\n</code></pre> To simplify the build process, you can add a <code>build</code> task to your <code>pixi.toml</code> file using the following command: <pre><code>pixi task add build \"cargo build\"\n</code></pre> Which creates this field in the <code>pixi.toml</code> file: pixi.toml<pre><code>[tasks]\nbuild = \"cargo build\"\n</code></pre></p> <p>And now you can build your project using: <pre><code>pixi run build\n</code></pre></p> <p>You can also run your project using: <pre><code>pixi run cargo run\n</code></pre> Which you can simplify with a task again. <pre><code>pixi task add start \"cargo run\"\n</code></pre></p> <p>So you should get the following output: <pre><code>pixi run start\nHello, world!\n</code></pre></p> <p>Congratulations, you have a Rust project running on your machine with pixi!</p>"},{"location":"tutorials/rust/#next-steps-why-is-this-useful-when-there-is-rustup","title":"Next steps, why is this useful when there is <code>rustup</code>?","text":"<p>Cargo is not a binary package manager, but a source-based package manager. This means that you need to have the Rust compiler installed on your system to use it. And possibly other dependencies that are not included in the <code>cargo</code> package manager. For example, you might need to install <code>openssl</code> or <code>libssl-dev</code> on your system to build a package. This is the case for <code>pixi</code> as well, but <code>pixi</code> will install these dependencies in your project folder, so you don't have to worry about them.</p> <p>Add the following dependencies to your cargo project: <pre><code>pixi run cargo add git2\n</code></pre></p> <p>If your system is not preconfigured to build C and have the <code>libssl-dev</code> package installed you will not be able to build the project: <pre><code>pixi run build\n...\nCould not find directory of OpenSSL installation, and this `-sys` crate cannot\nproceed without this knowledge. If OpenSSL is installed and this crate had\ntrouble finding it,  you can set the `OPENSSL_DIR` environment variable for the\ncompilation process.\n\nMake sure you also have the development packages of openssl installed.\nFor example, `libssl-dev` on Ubuntu or `openssl-devel` on Fedora.\n\nIf you're in a situation where you think the directory *should* be found\nautomatically, please open a bug at https://github.com/sfackler/rust-openssl\nand include information about your system as well as this message.\n\n$HOST = x86_64-unknown-linux-gnu\n$TARGET = x86_64-unknown-linux-gnu\nopenssl-sys = 0.9.102\n\n\nIt looks like you're compiling on Linux and also targeting Linux. Currently this\nrequires the `pkg-config` utility to find OpenSSL but unfortunately `pkg-config`\ncould not be found. If you have OpenSSL installed you can likely fix this by\ninstalling `pkg-config`.\n...\n</code></pre> You can fix this, by adding the necessary dependencies for building git2, with pixi: <pre><code>pixi add openssl pkg-config compilers\n</code></pre></p> <p>Now you should be able to build your project again: <pre><code>pixi run build\n...\n   Compiling git2 v0.18.3\n   Compiling my_rust_project v0.1.0 (/my_rust_project)\n    Finished dev [unoptimized + debuginfo] target(s) in 7.44s\n     Running `target/debug/my_rust_project`\n</code></pre></p>"},{"location":"tutorials/rust/#extra-add-more-tasks","title":"Extra: Add more tasks","text":"<p>You can add more tasks to your <code>pixi.toml</code> file to simplify your workflow.</p> <p>For example, you can add a <code>test</code> task to run your tests: <pre><code>pixi task add test \"cargo test\"\n</code></pre></p> <p>And you can add a <code>clean</code> task to clean your project: <pre><code>pixi task add clean \"cargo clean\"\n</code></pre></p> <p>You can add a formatting task to your project: <pre><code>pixi task add fmt \"cargo fmt\"\n</code></pre></p> <p>You can extend these tasks to run multiple commands with the use of the <code>depends-on</code> field. <pre><code>pixi task add lint \"cargo clippy\" --depends-on fmt\n</code></pre></p>"},{"location":"tutorials/rust/#conclusion","title":"Conclusion","text":"<p>In this tutorial, we showed you how to create a Rust project using <code>pixi</code>. We also showed you how to add dependencies to your project using <code>pixi</code>. This way you can make sure that your project is reproducible on any system that has <code>pixi</code> installed.</p>"},{"location":"tutorials/rust/#show-off-your-work","title":"Show Off Your Work!","text":"<p>Finished with your project? We'd love to see what you've created! Share your work on social media using the hashtag #pixi and tag us @prefix_dev. Let's inspire the community together!</p>"}]}